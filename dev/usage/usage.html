<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage Â· FlowCytometry.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="FlowCytometry.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FlowCytometry.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li class="is-active"><a class="tocitem" href="usage.html">Usage</a><ul class="internal"><li><a class="tocitem" href="#Basics-of-the-FlowCytometry.jl-structures"><span>Basics of the FlowCytometry.jl structures</span></a></li><li><a class="tocitem" href="#Gating"><span>Gating</span></a></li><li><a class="tocitem" href="#Compensation"><span>Compensation</span></a></li><li><a class="tocitem" href="#Dimensionality-reduction"><span>Dimensionality reduction</span></a></li><li><a class="tocitem" href="#Clustering"><span>Clustering</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../gating/gating.html">Automatic Quality Control</a></li><li><a class="tocitem" href="../compensation/compensation.html">Compensation</a></li><li><a class="tocitem" href="../autofluorescence/autofluorescence.html">Autofluorescence compensation</a></li></ul></li><li><a class="tocitem" href="../API.html">API</a></li><li><a class="tocitem" href="../References.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="usage.html">Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="usage.html">Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gatocor/FlowCytometry.jl/blob/master/docs/src/usage/usage.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>We are going over the main functionality of the FlowCytometry package.</p><p>For this tutorial you will need to have installed the following packages:</p><ul><li>FlowCytometry </li><li>Plots for the visualization of the results</li><li>CSV for uploading files</li><li>DataFrames as storage </li></ul><p>First we upload the required packages.</p><pre><code class="language-julia hljs">using FlowCytometry
using PyPlot
using CSV
using DataFrames</code></pre><pre><code class="nohighlight hljs">â”Œ Info: Precompiling FlowCytometry [dda4a566-a714-4635-9e97-d7f3f719a55d]
â”” @ Base loading.jl:1342
WARNING: Method definition compensate!(FlowCytometry.FlowCytometryExperiment) in module Compensation at /home/gabriel/Documents/FlowCytometry/src/compensation.jl:155 overwritten at /home/gabriel/Documents/FlowCytometry/src/compensation.jl:188.
  ** incremental compilation may be fatally broken for this module **

[33m[1mâ”Œ [22m[39m[33m[1mWarning: [22m[39mReplacing docs for `FlowCytometry.Compensation.compensate! :: Tuple{FlowCytometry.FlowCytometryExperiment}` in module `FlowCytometry.Compensation`
[33m[1mâ”” [22m[39m[90m@ Base.Docs docs/Docs.jl:240[39m</code></pre><p>&lt;div style=&quot;padding: 1em; background-color: #f8d6da; border: 1px solid #f5c6cb; font-weight: bold;&quot;&gt; &lt;p&gt;The WebIO Jupyter extension was not detected. See the &lt;a href=&quot;https://juliagizmos.github.io/WebIO.jl/latest/providers/ijulia/&quot; target=&quot;_blank&quot;&gt;     WebIO Jupyter integration documentation &lt;/a&gt; for more information. &lt;/div&gt;</p><h2 id="Basics-of-the-FlowCytometry.jl-structures"><a class="docs-heading-anchor" href="#Basics-of-the-FlowCytometry.jl-structures">Basics of the FlowCytometry.jl structures</a><a id="Basics-of-the-FlowCytometry.jl-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Basics-of-the-FlowCytometry.jl-structures" title="Permalink"></a></h2><p>The Flow cytometry package works around a few structures that help with the upload and manipulation of flow cytometry data.</p><p>The basic structure is <strong>FlowCytometryExperiment</strong>. The structure follows a very similar struture to the AnnData object for scRNA seq analysis of <a href="https://scanpy.readthedocs.io/en/latest/usage-principles.html#anndata">Scanpy</a>.</p><h3 id="Loading"><a class="docs-heading-anchor" href="#Loading">Loading</a><a id="Loading-1"></a><a class="docs-heading-anchor-permalink" href="#Loading" title="Permalink"></a></h3><p>We can construct it manually starting from a measures matrix. Let&#39;s make a initialization of experiment with 100 cells and 10 channels.</p><pre><code class="language-julia hljs">fcs = FlowCytometryExperiment(rand(100,10));</code></pre><p>Alternatively, we can directly load a fcs experiment.</p><pre><code class="language-julia hljs">fcs = loadFCExperiment(&quot;FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC Stained Control_006.fcs&quot;);</code></pre><h3 id="Accesing-the-properties"><a class="docs-heading-anchor" href="#Accesing-the-properties">Accesing the properties</a><a id="Accesing-the-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Accesing-the-properties" title="Permalink"></a></h3><p>The structure contains several properties useful for the analysis.</p><ul><li><strong>X</strong> Matrix of Cells X Channel of the experiment.</li><li><strong>obs</strong> Dataframe with all the metainformation of the cells</li><li><strong>var</strong> Dataframe with all the metainformation of the channels</li><li><strong>obsm</strong> Dictionary containing transformed matrices of the original data.</li><li><strong>layers</strong> Dictionary containing Cells X Channel matrices of data that are required to control (e.g. Raw matrix).</li><li><strong>gates</strong> List of Gate and Gate set objects</li><li><strong>uns</strong> Dictionary contining all the metainformation of algorithms applied to the data.</li></ul><p>The data uploaded before contains for now a matrix with 5000 cells and 35 channels.</p><pre><code class="language-julia hljs">fcs.X</code></pre><p>The experiment metainformation has been stored in <code>.uns[&quot;ExperimentInformation&quot;]</code>.</p><pre><code class="language-julia hljs">fcs.uns[&quot;ExperimentInformation&quot;]</code></pre><p>And we have the name of the channels in <code>.channels</code>.</p><pre><code class="language-julia hljs">fcs.channels</code></pre><p>It is useful to note than the channels can be accessed directly by calling directly to the FlowCytometryExperiment object as <code>fcs[channel_of_interest]</code>. Let&#39;s use this property for ploting a scatterplot of two channels.</p><pre><code class="language-julia hljs">fig, ax = subplots(1,1)
ax.scatter(fcs[&quot;APC-A&quot;],fcs[&quot;APC-R700-A&quot;],s=10)
ax.set_xlabel(&quot;APC-R700-A&quot;)
ax.set_ylabel(&quot;APC-A&quot;)
ax.set_title(&quot;Control experiment APC Dye&quot;)</code></pre><p>We can already see from this data the spillover effect of APC-A to APC-R700-A.</p><h2 id="Gating"><a class="docs-heading-anchor" href="#Gating">Gating</a><a id="Gating-1"></a><a class="docs-heading-anchor-permalink" href="#Gating" title="Permalink"></a></h2><p>Flow compensation usually requires of quality control of the cells and measures change in proportion of cells between experimennts to see if there is changes in the number of cells present in specific regions of the channel space.</p><p>We can define gates for our experiment in several ways.</p><h3 id="Manual-gating"><a class="docs-heading-anchor" href="#Manual-gating">Manual gating</a><a id="Manual-gating-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-gating" title="Permalink"></a></h3><p>We can define a manual gates by calling the function <code>Gating.manualGating!</code>. This will start an app that can be accessed in any browser by writing <code>localhost::channel</code>, for the channel prompted by the function. When desiring to stop adding gates, you will have just to kill the app with <code>ctr+C</code> or similar and the gates will be added to the <code>FlowCytometryExperiment</code> object.</p><pre><code class="language-julia hljs">Gating.manualGating!(fcs)</code></pre><p>When calling the function, in the browser you will see a page like this:</p><p><img src="ManualGating.png" alt/></p><h3 id="Automatic-gating"><a class="docs-heading-anchor" href="#Automatic-gating">Automatic gating</a><a id="Automatic-gating-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-gating" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Statistics, LinearAlgebra</code></pre><pre><code class="language-julia hljs">det(cov(rand(20,20)))</code></pre><pre><code class="language-julia hljs">mean(rand(4,5),dims=1)[1,:]</code></pre><pre><code class="language-julia hljs">automaticQC!(fcs)</code></pre><pre><code class="language-julia hljs">fig,ax = subplots(1,5,figsize=[25,3])

ax[1].fill([i[1] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],[i[2] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],alpha=0.5,zorder=-1,color=&quot;lightBlue&quot;)
ax[1].scatter(fcs[&quot;FSC-A&quot;],fcs[&quot;SSC-A&quot;],s=2)

ax[2].fill([i[1] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],[i[2] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],alpha=0.5,zorder=-1,color=&quot;lightBlue&quot;)
ax[2].fill([i[1] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step2_ExcludeMaximums&quot;]],[i[2] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step2_ExcludeMaximums&quot;]],alpha=0.5,zorder=-1,color=&quot;orange&quot;)
ax[2].scatter(fcs[&quot;FSC-A&quot;],fcs[&quot;SSC-A&quot;],c=fcs.obs[:,&quot;automaticQC_density1&quot;],cmap=&quot;Spectral_r&quot;,s=2)
ax[2].scatter(fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][1],fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][2],color=&quot;k&quot;,s=50)
ax[2].scatter([fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][1]],[fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][2]],color=&quot;orange&quot;,s=50)

ax[3].fill([i[1] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],[i[2] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],alpha=0.5,zorder=-1,color=&quot;lightBlue&quot;)
ax[3].fill([i[1] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step5_Tesselation&quot;]],[i[2] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step5_Tesselation&quot;]],alpha=0.5,zorder=-1,color=&quot;orange&quot;)
ax[3].scatter(fcs[&quot;FSC-A&quot;],fcs[&quot;SSC-A&quot;],c=fcs.obs[:,&quot;automaticQC_density1&quot;],cmap=&quot;Spectral_r&quot;,s=2)
ax[3].scatter(fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][1],fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][2],color=&quot;k&quot;,s=50)
ax[3].scatter([fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][1]],[fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][2]],color=&quot;orange&quot;,s=50)

ax[4].fill([i[1] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],[i[2] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step1_TrimOutliers&quot;]],alpha=0.5,zorder=-1,color=&quot;lightBlue&quot;)
ax[4].fill([i[1] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step6_Rectangle&quot;]],[i[2] for i in fcs.uns[&quot;automaticQC&quot;][&quot;Step6_Rectangle&quot;]],alpha=0.5,zorder=-1,color=&quot;orange&quot;)
ax[4].scatter(fcs[&quot;FSC-A&quot;],fcs[&quot;SSC-A&quot;],c=fcs.obs[:,&quot;automaticQC_density1&quot;],cmap=&quot;Spectral_r&quot;,s=2)
ax[4].scatter(fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][1],fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][2],color=&quot;k&quot;,s=50)
ax[4].scatter([fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][1]],[fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][2]],color=&quot;orange&quot;,s=50)

ax[5].fill([i[1] for i in fcs.gates[&quot;automaticQC&quot;].polygon],[i[2] for i in fcs.gates[&quot;automaticQC&quot;].polygon],alpha=1,facecolor=&quot;none&quot;,edgecolor=&quot;red&quot;)
ax[5].scatter(fcs[&quot;FSC-A&quot;],fcs[&quot;SSC-A&quot;],c=fcs.obs[:,&quot;automaticQC_density1&quot;],cmap=&quot;Spectral_r&quot;,s=2)
ax[5].scatter(fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][1],fcs.uns[&quot;automaticQC&quot;][&quot;Step3_LocalMaximums&quot;][2],color=&quot;k&quot;,s=50)
ax[5].scatter([fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][1]],[fcs.uns[&quot;automaticQC&quot;][&quot;Step4_GlobalMaximum&quot;][2]],color=&quot;orange&quot;,s=50)

for a in ax
    a.set_xlim(0,30E4)
    a.set_ylim(0,30E4)
    a.set_xticks([0,30E4])
    a.set_yticks([0,30E4])
end
</code></pre><h2 id="Compensation"><a class="docs-heading-anchor" href="#Compensation">Compensation</a><a id="Compensation-1"></a><a class="docs-heading-anchor-permalink" href="#Compensation" title="Permalink"></a></h2><p>Most part of flow cytometry experiments use several signaling channels. Some of the most common experimental as flow cytometry or spectral cytometry suffer from spillover/mixing of the information among the channels. To correct this behavior and having uncoupled signals, one-fluorophore control experiments are performed in order to compute what is called the compensation matrice to uncouple the channels.</p><h3 id="Loading-control-experiments"><a class="docs-heading-anchor" href="#Loading-control-experiments">Loading control experiments</a><a id="Loading-control-experiments-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-control-experiments" title="Permalink"></a></h3><p>We can upload the control experiments in a special structure named <code>FlowCytometryControl</code>, that is more less a container of diferent <code>FlowCytometryExperiment</code>. Each control experiment is assigned a channel that corresponds to the maximum peack of its spectrum. This is very important to when computing the compensation matrix. The best way of uploading the data is by assigning the different control files to the according channels.</p><p>In this example we have a file that has already this assignation:</p><pre><code class="language-julia hljs">controls = CSV.read(&quot;FlowRepository_FR-FCM-Z2SS_files/attachments/fcs_control.csv&quot;,FlowCytometry.DataFrame)
print(controls[1:5,:])</code></pre><p>We will construct a dictionary assigning file to channel.</p><pre><code class="language-julia hljs">fileChannelAssignation = Dict([string(&quot;FlowRepository_FR-FCM-Z2SS_files/&quot;,i)=&gt;String(j) for (i,j) in eachrow(controls[:,[&quot;filename&quot;,&quot;dye&quot;]])])</code></pre><p>Now we can load the data.</p><pre><code class="language-julia hljs">fcsControl = loadFCControls(fileChannelAssignation);</code></pre><h3 id="Compute-compensation-matrix"><a class="docs-heading-anchor" href="#Compute-compensation-matrix">Compute compensation matrix</a><a id="Compute-compensation-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-compensation-matrix" title="Permalink"></a></h3><p>With the data uploaded we can compute the compensation matrix from the <code>FlowCytometryControl</code> object.</p><pre><code class="language-julia hljs">Compensation.computeCompensationMatrix!(fcsControl)</code></pre><h3 id="Compensate-datasets"><a class="docs-heading-anchor" href="#Compensate-datasets">Compensate datasets</a><a id="Compensate-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Compensate-datasets" title="Permalink"></a></h3><p>With the compensated matrix computed, we can compensate the data. There are several methods of proceeding with the compensation.</p><ol><li>Compensate the control data</li></ol><pre><code class="language-julia hljs">experimentUncompensated = deepcopy(fcsControl.controls[&quot;APC-A&quot;]) #Make a copy before compensation
Compensation.compensate!(fcsControl)</code></pre><p>Now we can visualize the results of the compensation and see that it has been correctly compensated.</p><pre><code class="language-julia hljs">experiment = fcsControl.controls[&quot;APC-A&quot;]
scatter(experimentUncompensated[&quot;APC-A&quot;],experimentUncompensated[&quot;APC-R700-A&quot;],label=&quot;Not compensated&quot;)
scatter!(experiment[&quot;APC-A&quot;],experiment[&quot;APC-R700-A&quot;],label=&quot;Compensated&quot;,xlabel=&quot;APC-A&quot;,ylabel=&quot;APC-R700-A&quot;,title=&quot;Control APC-A&quot;)
xlabel!(&quot;APC-A&quot;)
ylabel!(&quot;APC-R700-A&quot;)</code></pre><ol><li>Compensate the a <code>FlowCytometryExperiment</code> object with a <code>FlowCytometryControl</code> object</li></ol><pre><code class="language-julia hljs">fcsCopy = deepcopy(fcs)
Compensation.compensate!(fcsCopy,control=fcsControl)</code></pre><ol><li>Assign the compensation matrix of a <code>FlowCytometryControl</code> to a <code>FlowCytometryExperiment</code> and then compensate.</li></ol><pre><code class="language-julia hljs">fcsCopy = deepcopy(fcs)
Compensation.assignCompensation!(fcsCopy,control=fcsControl)
Compensation.compensate!(fcsCopy)</code></pre><h2 id="Dimensionality-reduction"><a class="docs-heading-anchor" href="#Dimensionality-reduction">Dimensionality reduction</a><a id="Dimensionality-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensionality-reduction" title="Permalink"></a></h2><p>In some datasets, the data is very high dimensional and visualizing all pairwise steps may not be possible or hard to interpret. For that reason, we can apply several dimensionality reduction methods to summarize the data.</p><p>Let&#39;s see that by constructing a toy dataset with two cell types. This data doesn&#39;t show well separated by any particular plot in of two of the variables. However, PCA analysis or UMAP projection are able to show the separation between the two clusters.</p><p>All this visualizations are stored as transformations of the original data in <code>.obms</code>.</p><pre><code class="language-julia hljs">X = [randn(1000,10); (randn(1000,10).+[0 2 0 2 0 2 0 2 0 0])];
fcs = FlowCytometryExperiment(X);</code></pre><pre><code class="language-julia hljs">DimensionalityReduction.pca!(fcs)</code></pre><pre><code class="language-julia hljs">DimensionalityReduction.umap!(fcs)</code></pre><pre><code class="language-julia hljs">plot(scatter(fcs[&quot;1&quot;],fcs[&quot;2&quot;],title=&quot;Variables&quot;),
    scatter(fcs.obsm[&quot;pca&quot;][:,1],fcs.obsm[&quot;pca&quot;][:,2],title=&quot;PC&quot;),
    scatter(fcs.obsm[&quot;umap&quot;][:,1],fcs.obsm[&quot;umap&quot;][:,2],title=&quot;UMAP&quot;),
    layout=(1,3),legend=false,size=[1200,400])</code></pre><h2 id="Clustering"><a class="docs-heading-anchor" href="#Clustering">Clustering</a><a id="Clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering" title="Permalink"></a></h2><p>One of the main uses of cytometry data is to cluster data by cell types. Several methods are already implemented in the package. Resuing the toy model before.</p><pre><code class="language-julia hljs">Clustering.kmeans!(fcs,n_components=2)</code></pre><pre><code class="language-julia hljs">Clustering.agglomerative!(fcs,n_components=2)</code></pre><pre><code class="language-julia hljs">plot(scatter(fcs.obsm[&quot;pca&quot;][:,1],fcs.obsm[&quot;pca&quot;][:,2],markercolor=Array(fcs.obs[:,&quot;kmeans&quot;]),title=&quot;KMeans&quot;),
    scatter(fcs.obsm[&quot;pca&quot;][:,1],fcs.obsm[&quot;pca&quot;][:,2],markercolor=Array(fcs.obs[:,&quot;agglomerative&quot;]),title=&quot;Agglomerative&quot;),
    layout=(1,2),legend=false,size=[800,400])</code></pre><pre><code class="language-julia hljs">using Distributions</code></pre><pre><code class="language-julia hljs">c = [.1 .01 .01;.01 .1 .02;.01 .02 .2]
X = permutedims(rand(MultivariateNormal([0,1,2],c),1000));
Y = permutedims(rand(MultivariateNormal([0,3,2],c),1000));
fcs = FlowCytometryExperiment([X;Y]);</code></pre><pre><code class="language-julia hljs">Clustering.gaussianMixture!(fcs,k=3,initialization=&quot;kmeans&quot;,verbose=true)</code></pre><pre><code class="nohighlight hljs">[32mProgress: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| Time: 0:00:03[39m
[34m  iter:  2000[39m</code></pre><pre><code class="language-julia hljs">plot(fcs.uns[&quot;gaussianMixture&quot;][&quot;means&quot;][:,1,2])
plot(fcs.uns[&quot;gaussianMixture&quot;][&quot;means&quot;][:,2,2])
plot(fcs.uns[&quot;gaussianMixture&quot;][&quot;means&quot;][:,3,2])</code></pre><p><img src="Usage_files/Usage_55_0.png" alt="png"/></p><pre><code class="nohighlight hljs">1-element Vector{PyCall.PyObject}:
 PyObject &lt;matplotlib.lines.Line2D object at 0x7f3aad1677f0&gt;</code></pre><pre><code class="language-julia hljs">for i in 1:3
    plot(fcs.uns[&quot;gaussianMixture&quot;][&quot;weights&quot;][:,i])
end</code></pre><p><img src="Usage_files/Usage_56_0.png" alt="png"/></p><pre><code class="language-julia hljs"></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">Â« Home</a><a class="docs-footer-nextpage" href="../gating/gating.html">Automatic Quality Control Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 5 January 2023 16:34">Thursday 5 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
