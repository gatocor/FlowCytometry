var documenterSearchIndex = {"docs":
[{"location":"Usage/Usage.html#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"We are going over the main functionality of the FlowCytometry package.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"For this tutorial you will need to have installed the following packages:","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"FlowCytometry \nPlots for the visualization of the results\nCSV for uploading files\nDataFrames as storage ","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"First we upload the required packages.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"using FlowCytometry\nusing Plots\nusing CSV\nusing DataFrames","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"<div style=\"padding: 1em; background-color: #f8d6da; border: 1px solid #f5c6cb; font-weight: bold;\"> <p>The WebIO Jupyter extension was not detected. See the <a href=\"https://juliagizmos.github.io/WebIO.jl/latest/providers/ijulia/\" target=\"_blank\">     WebIO Jupyter integration documentation </a> for more information. </div>","category":"page"},{"location":"Usage/Usage.html#Basics-of-the-FlowCytometry.jl-structures","page":"Usage","title":"Basics of the FlowCytometry.jl structures","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"The Flow cytometry package works around a few structures that help with the upload and manipulation of flow cytometry data.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"The basic structure is FlowCytometryExperiment. The structure follows a very similar struture to the AnnData object for scRNA seq analysis of Scanpy.","category":"page"},{"location":"Usage/Usage.html#Loading","page":"Usage","title":"Loading","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"We can construct it manually starting from a measures matrix. Let's make a initialization of experiment with 100 cells and 10 channels.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcs = FlowCytometryExperiment(rand(100,10));","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Alternatively, we can directly load a fcs experiment.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcs = loadFCExperiment(\"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC Stained Control_006.fcs\");","category":"page"},{"location":"Usage/Usage.html#Accesing-the-properties","page":"Usage","title":"Accesing the properties","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"The structure contains several properties useful for the analysis.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"X Matrix of Cells X Channel of the experiment.\nobs Dataframe with all the metainformation of the cells\nvar Dataframe with all the metainformation of the channels\nobsm Dictionary containing transformed matrices of the original data.\nlayers Dictionary containing Cells X Channel matrices of data that are required to control (e.g. Raw matrix).\ngates List of Gate and Gate set objects\nuns Dictionary contining all the metainformation of algorithms applied to the data.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"The data uploaded before contains for now a matrix with 5000 cells and 35 channels.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcs.X","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"5000×35 Matrix{Float64}:\n 2303.74      416.599   1283.72    …  164.319   112.581     806.962\n   74.9271    118.738     38.9001     103.387    43.4448     31.328\n   -8.80664    37.3513    69.7797      53.6129  -12.1771     16.3808\n   13.1381     74.3996   117.378      113.407    58.6642    109.884\n   61.805     154.62      83.2257     151.944    61.3532     92.8747\n  120.452     149.492    118.274   …  126.721    28.8629     98.2071\n   47.0315     90.03      65.6665      59.3534   40.6711     45.4934\n 3250.81      510.924   1784.68        83.2978  149.613    1271.07\n  129.82      171.005    104.946      218.265    89.9069    138.593\n 4507.53      762.57    2983.45       151.153   175.381    1292.75\n   44.5258     98.8863    90.7532  …   96.0772    7.18318    72.9165\n 3067.69      499.695   1977.24       184.278   133.984     779.138\n  106.038      73.6164    72.8483      91.8869   30.9219     83.9338\n    ⋮                              ⋱                       \n 4526.39      922.335   3162.07       228.424   163.164    1784.55\n 3204.06      453.676   1997.38       117.517    92.6973    995.466\n 3541.12      521.124   2009.79    …   96.7421  142.616    1033.12\n  110.326      96.0595    92.4247     104.981    64.8256     76.8489\n 4377.92      790.997   3020.12       156.357   163.928    1571.42\n  162.128     197.74     165.195      135.382    49.7978    116.674\n 1854.82     1089.18    1323.15       522.704   530.454    1234.77\n 4850.33     1584.76    3109.43    …  703.122   539.034    1849.48\n   62.8767    123.013    162.019       88.8254   57.7122     17.3599\n  133.58      103.552     55.547       87.4273   24.1988    263.921\n  -28.8662    110.622    198.375       68.2685   25.5013     98.1429\n    4.39487    97.8623   130.614       88.426    38.1077     31.6543","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"The experiment metainformation has been stored in .uns[\"ExperimentInformation\"].","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcs.uns[\"ExperimentInformation\"]","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Dict{String, String} with 370 entries:\n  \"\\$P7G\"            => \"1.0\"\n  \"\\$P22E\"           => \"0,0\"\n  \"\\$P26E\"           => \"0,0\"\n  \"CREATOR\"          => \"BD FACSDiva Software Version 8.0.1\"\n  \"\\$P34R\"           => \"262144\"\n  \"\\$P27E\"           => \"0,0\"\n  \"\\$FIL\"            => \"Compensation Controls_APC Stained Control_006.fcs\"\n  \"\\$P2R\"            => \"262144\"\n  \"\\$P11V\"           => \"495\"\n  \"\\$P25R\"           => \"262144\"\n  \"\\$P2G\"            => \"1.0\"\n  \"P5BS\"             => \"0\"\n  \"P2DISPLAY\"        => \"LIN\"\n  \"LASER5DELAY\"      => \"31.30\"\n  \"P29DISPLAY\"       => \"LOG\"\n  \"P32DISPLAY\"       => \"LOG\"\n  \"P3MS\"             => \"0\"\n  \"\\$P24R\"           => \"262144\"\n  \"\\$P9G\"            => \"1.0\"\n  \"\\$P14B\"           => \"32\"\n  \"P27DISPLAY\"       => \"LOG\"\n  \"EXPORT USER NAME\" => \"CarlyWhyte\"\n  \"\\$P10B\"           => \"32\"\n  \"\\$P9N\"            => \"BB660-P-A\"\n  \"\\$P3E\"            => \"0,0\"\n  ⋮                  => ⋮","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"And we have the name of the channels in .channels.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcs.channels","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"35-element Vector{String}:\n \"PE-Cy5.5-A\"\n \"BB660-P-A\"\n \"BV650-A\"\n \"BUV615-P-A\"\n \"BYG790-A\"\n \"SSC-H\"\n \"BV786-A\"\n \"SSC-W\"\n \"BV570-A\"\n \"APC-A\"\n \"BV421-A\"\n \"PE-CF594-A\"\n \"BB700-P-A\"\n ⋮\n \"BYG670-A\"\n \"BUV661-A\"\n \"BV750-P-A\"\n \"FITC-A\"\n \"APC-R700-A\"\n \"BB630-A\"\n \"BUV496-A\"\n \"BUV737-A\"\n \"BYG584-A\"\n \"BUV563-A\"\n \"BB790-P-A\"\n \"BV711-A\"","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"It is useful to note than the channels can be accessed directly by calling directly to the FlowCytometryExperiment object as fcs[channel_of_interest]. Let's use this property for ploting a scatterplot of two channels.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"scatter(fcs[\"APC-A\"],fcs[\"APC-R700-A\"],label=\"cells\",xlabel=\"APC-R700-A\",ylabel=\"APC-A\",title=\"Control experiment APC Dye\")","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"(Image: svg)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"We can already see from this data the spillover effect of APC-A to APC-R700-A.","category":"page"},{"location":"Usage/Usage.html#Gating","page":"Usage","title":"Gating","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Flow compensation usually requires of quality control of the cells and measures change in proportion of cells between experimennts to see if there is changes in the number of cells present in specific regions of the channel space.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"We can define gates for our experiment in several ways.","category":"page"},{"location":"Usage/Usage.html#Manual-gating","page":"Usage","title":"Manual gating","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"We can define a manual gates by calling the function Gating.manualGating!. This will start an app that can be accessed in any browser by writing localhost::channel, for the channel prompted by the function. When desiring to stop adding gates, you will have just to kill the app with ctr+C or similar and the gates will be added to the FlowCytometryExperiment object.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Gating.manualGating!(fcs)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"┌ Info: Listening on: 0.0.0.0:8050\n└ @ HTTP.Servers /home/gabriel/.julia/packages/HTTP/aTjcj/src/Servers.jl:268","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"When calling the function, in the browser you will see a page like this:","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"Usage/Usage.html#Compensation","page":"Usage","title":"Compensation","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Most part of flow cytometry experiments use several signaling channels. Some of the most common experimental as flow cytometry or spectral cytometry suffer from spillover/mixing of the information among the channels. To correct this behavior and having uncoupled signals, one-fluorophore control experiments are performed in order to compute what is called the compensation matrice to uncouple the channels.","category":"page"},{"location":"Usage/Usage.html#Loading-control-experiments","page":"Usage","title":"Loading control experiments","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"We can upload the control experiments in a special structure named FlowCytometryControl, that is more less a container of diferent FlowCytometryExperiment. Each control experiment is assigned a channel that corresponds to the maximum peack of its spectrum. This is very important to when computing the compensation matrix. The best way of uploading the data is by assigning the different control files to the according channels.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"In this example we have a file that has already this assignation:","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"controls = CSV.read(\"FlowRepository_FR-FCM-Z2SS_files/attachments/fcs_control.csv\",FlowCytometry.DataFrame)\nprint(controls[1:5,:])","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"\u001b[1m5×4 DataFrame\u001b[0m\n\u001b[1m Row \u001b[0m│\u001b[1m filename                          \u001b[0m\u001b[1m dye        \u001b[0m\u001b[1m antigen    \u001b[0m\u001b[1m wavelength \u001b[0m\n\u001b[1m     \u001b[0m│\u001b[90m String                            \u001b[0m\u001b[90m String15   \u001b[0m\u001b[90m String15   \u001b[0m\u001b[90m Int64      \u001b[0m\n─────┼───────────────────────────────────────────────────────────────────────\n   1 │ Compensation Controls_APC Staine…  APC-A       CD4/CD8            660\n   2 │ Compensation Controls_APC-H7 Sta…  APC-H7-A    viability          785\n   3 │ Compensation Controls_APC-R700 S…  APC-R700-A  MHC-II             719\n   4 │ Compensation Controls_BB630 Stai…  BB630-A     CD3/Thy1.2         631\n   5 │ Compensation Controls_BB660-P St…  BB660-P-A   CD45.2/CD3         667","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"We will construct a dictionary assigning file to channel.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fileChannelAssignation = Dict([string(\"FlowRepository_FR-FCM-Z2SS_files/\",i)=>String(j) for (i,j) in eachrow(controls[:,[\"filename\",\"dye\"]])])","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Dict{String, String} with 28 entries:\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BYG79… => \"BYG790-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV786… => \"BV786-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV80… => \"BUV805-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV605… => \"BV605-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV650… => \"BV650-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB660… => \"BB660-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB700… => \"BB700-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV73… => \"BUV737-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV750… => \"BV750-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC S… => \"APC-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB790… => \"BB790-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC-R… => \"APC-R700-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV570… => \"BV570-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_PE-CF… => \"PE-CF594-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_FITC … => \"FITC-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV421… => \"BV421-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB630… => \"BB630-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BYG58… => \"BYG584-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV480… => \"BV480-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV49… => \"BUV496-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BYG67… => \"BYG670-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC-H… => \"APC-H7-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV61… => \"BUV615-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV39… => \"BUV395-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV711… => \"BV711-A\"\n  ⋮                                                              => ⋮","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Now we can load the data.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcsControl = loadFCControls(fileChannelAssignation);","category":"page"},{"location":"Usage/Usage.html#Compute-compensation-matrix","page":"Usage","title":"Compute compensation matrix","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"With the data uploaded we can compute the compensation matrix from the FlowCytometryControl object.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Compensation.computeCompensationMatrix!(fcsControl)","category":"page"},{"location":"Usage/Usage.html#Compensate-datasets","page":"Usage","title":"Compensate datasets","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"With the compensated matrix computed, we can compensate the data. There are several methods of proceeding with the compensation.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Compensate the control data","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"experimentUncompensated = deepcopy(fcsControl.controls[\"APC-A\"]) #Make a copy before compensation\nCompensation.compensate!(fcsControl)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Now we can visualize the results of the compensation and see that it has been correctly compensated.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"experiment = fcsControl.controls[\"APC-A\"]\nscatter(experimentUncompensated[\"APC-A\"],experimentUncompensated[\"APC-R700-A\"],label=\"Not compensated\")\nscatter!(experiment[\"APC-A\"],experiment[\"APC-R700-A\"],label=\"Compensated\",xlabel=\"APC-A\",ylabel=\"APC-R700-A\",title=\"Control APC-A\")\nxlabel!(\"APC-A\")\nylabel!(\"APC-R700-A\")","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"(Image: svg)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Compensate the a FlowCytometryExperiment object with a FlowCytometryControl object","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcsCopy = deepcopy(fcs)\nCompensation.compensate!(fcsCopy,control=fcsControl)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Assign the compensation matrix of a FlowCytometryControl to a FlowCytometryExperiment and then compensate.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"fcsCopy = deepcopy(fcs)\nCompensation.assignCompensation!(fcsCopy,control=fcsControl)\nCompensation.compensate!(fcsCopy)","category":"page"},{"location":"Usage/Usage.html#Dimensionality-reduction","page":"Usage","title":"Dimensionality reduction","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"In some datasets, the data is very high dimensional and visualizing all pairwise steps may not be possible or hard to interpret. For that reason, we can apply several dimensionality reduction methods to summarize the data.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Let's see that by constructing a toy dataset with two cell types. This data doesn't show well separated by any particular plot in of two of the variables. However, PCA analysis or UMAP projection are able to show the separation between the two clusters.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"All this visualizations are stored as transformations of the original data in .obms.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"X = [randn(1000,10); (randn(1000,10).+[0 2 0 2 0 2 0 2 0 0])];\nfcs = FlowCytometryExperiment(X);","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"DimensionalityReduction.pca!(fcs)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"DimensionalityReduction.umap!(fcs)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"plot(scatter(fcs[\"1\"],fcs[\"2\"],title=\"Variables\"),\n    scatter(fcs.obsm[\"pca\"][:,1],fcs.obsm[\"pca\"][:,2],title=\"PC\"),\n    scatter(fcs.obsm[\"umap\"][:,1],fcs.obsm[\"umap\"][:,2],title=\"UMAP\"),\n    layout=(1,3),legend=false,size=[1200,400])","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"(Image: svg)","category":"page"},{"location":"Usage/Usage.html#Clustering","page":"Usage","title":"Clustering","text":"","category":"section"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"One of the main uses of cytometry data is to cluster data by cell types. Several methods are already implemented in the package. Resuing the toy model before.","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Clustering.kmeans!(fcs,n_components=2)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"Clustering.agglomerative!(fcs,n_components=2)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"plot(scatter(fcs.obsm[\"pca\"][:,1],fcs.obsm[\"pca\"][:,2],markercolor=Array(fcs.obs[:,\"kmeans\"]),title=\"KMeans\"),\n    scatter(fcs.obsm[\"pca\"][:,1],fcs.obsm[\"pca\"][:,2],markercolor=Array(fcs.obs[:,\"agglomerative\"]),title=\"Agglomerative\"),\n    layout=(1,2),legend=false,size=[800,400])","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"(Image: svg)","category":"page"},{"location":"Usage/Usage.html","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"References.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"References.html","page":"References","title":"References","text":"[1]  M. Dundar, F. Akova, H. Z. Yerebakan, and B. Rajwa, “A non-parametric Bayesian model for joint cell clustering and cluster matching: identification of anomalous sample phenotypes with random effects,” BMC Bioinformatics, vol. 15, no. 1, p. 314, Sep. 2014, doi: 10.1186/1471-2105-15-314.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[2] C. P. Roca et al., “AutoSpill is a principled framework that simplifies the analysis of multichromatic flow cytometry data,” Nat Commun, vol. 12, no. 1, Art. no. 1, May 2021, doi: 10.1038/s41467-021-23126-8.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[3] Y. Saeys, S. Van Gassen, and B. N. Lambrecht, “Computational flow cytometry: helping to make sense of high-dimensional immunology data,” Nat Rev Immunol, vol. 16, no. 7, Art. no. 7, Jul. 2016, doi: 10.1038/nri.2016.56.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[4] N. Aghaeepour et al., “Critical assessment of automated flow cytometry data analysis techniques,” Nat Methods, vol. 10, no. 3, Art. no. 3, Mar. 2013, doi: 10.1038/nmeth.2365.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[5] A. J. Cron and M. West, “Efficient Classification-Based Relabeling in Mixture Models,” Am Stat, vol. 65, no. 1, pp. 16–20, Feb. 2011, doi: 10.1198/tast.2011.10170.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[6] D. Novo, G. Grégori, and B. Rajwa, “Generalized unmixing model for multispectral flow cytometry utilizing nonsquare compensation matrices,” Cytometry Part A, vol. 83A, no. 5, pp. 508–520, 2013, doi: 10.1002/cyto.a.22272.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[7] L. Velten et al., “Human haematopoietic stem cell lineage commitment is a continuous process,” Nat Cell Biol, vol. 19, no. 4, Art. no. 4, Apr. 2017, doi: 10.1038/ncb3493.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[8] T. Sörensen, S. Baumgart, P. Durek, A. Grützkau, and T. Häupl, “immunoClust—An automated analysis pipeline for the identification of immunophenotypic signatures in high-dimensional cytometric datasets,” Cytometry Part A, vol. 87, no. 7, pp. 603–615, 2015, doi: 10.1002/cyto.a.22626.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[9] A. Mercuri et al., “Immunophenotypic analysis of hematopoiesis in patients suffering from Shwachman–Bodian–Diamond Syndrome,” European Journal of Haematology, vol. 95, no. 4, pp. 308–315, 2015, doi: 10.1111/ejh.12490.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[10] I. P. Sugár and S. C. Sealfon, “Misty Mountain clustering: application to fast unsupervised flow cytometry gating,” BMC Bioinformatics, vol. 11, p. 502, Oct. 2010, doi: 10.1186/1471-2105-11-502.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[11] L. Ferrer‐Font, C. Pellefigues, J. U. Mayer, S. J. Small, M. C. Jaimes, and K. M. Price, “Panel Design and Optimization for High‐Dimensional Immunophenotyping Assays Using Spectral Flow Cytometry,” Current Protocols in Cytometry, vol. 92, no. 1, Mar. 2020, doi: 10.1002/cpcy.70.","category":"page"},{"location":"index.html#FlowCytometry.jl-Documentation","page":"Home","title":"FlowCytometry.jl Documentation","text":"","category":"section"},{"location":"API.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"API.html#Basic-Structures","page":"API","title":"Basic Structures","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"FlowCytometryGate\nFlowCytometryControl\nFlowCytometryExperiment","category":"page"},{"location":"API.html#FlowCytometry.FlowCytometryGate","page":"API","title":"FlowCytometry.FlowCytometryGate","text":"struct FlowCytometryGate\n\nStructure that contains information from a gating process of the data.\n\nElements:\n\nchannels::Tuple{String,String} Channel names of the gate.\npolygon::Vector{Tuple{Real,Real}} Points of poligon that defines the gate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#FlowCytometry.FlowCytometryControl","page":"API","title":"FlowCytometry.FlowCytometryControl","text":"mutable struct FlowCytometryControl\n\nStructure that stores the data coming from control stainings for correcting for spillover.  In order for the system to compute properly the spillover matrix, the names of the dictionary must correspond with the names in the channel labels in var.\n\nElements:\n\nchannels::Vector{String} Name of the channels in the experiment.\ncontrols::Dict{String,FlowCytometryExperiment} Dictionary of FlowCytometryExperiments containing the control experiments.\ncompensationMatrix::Union{Nothing,Matrix{<:AbstractFloat}} Spillover matrix inverted.\nuns::Dict{String,Any} Dictionary where to store metainformation from spillover algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API.html#FlowCytometry.FlowCytometryExperiment","page":"API","title":"FlowCytometry.FlowCytometryExperiment","text":"mutable struct FlowCytometryExperiment\n\nStructure containing a Flow Cytometry experiment and all the processes applyied to it.\n\nElements:   \n\nchannels::Vector{String} Name of the channels in the experiment.\nX::Matrix{AbstractFloat} Matrix of Cells X Channel of the experiment.\nobs::DataFrame Dataframe with all the metainformation of the cells\nvar::DataFrame Dataframe with all the metainformation of the channels\nobsm::Dict{String,Matrix{AbstractFloat}} Dictionary containing transformed matrices of the original data.\nlayers::Dict{String,Matrix{AbstractFloat}} Dictionary containing Cells X Channel matrices of data that are required to control (e.g. Raw matrix).\ngates::Dict{String,FlowCytometryGate} List of Gate and Gate set objects\nuns::Dict{String,Any} Dictionary contining all the metainformation of algorithms applied to the data.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Operations-with-structures","page":"API","title":"Operations with structures","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"removeCells\nremoveCells!\nremoveChannels\nremoveChannels!\nrenameControl!\ncheckControlNames","category":"page"},{"location":"API.html#FlowCytometry.removeCells","page":"API","title":"FlowCytometry.removeCells","text":"function removeCells(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove cells from the dataset and return a copy.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of cells to be removed.\n\nReturns FlowCytometryExperiment with the cells not prunned.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.removeCells!","page":"API","title":"FlowCytometry.removeCells!","text":"function removeCells!(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove cells from the dataset.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of cells to be removed.\n\nReturns Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.removeChannels","page":"API","title":"FlowCytometry.removeChannels","text":"function removeChannels(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove channels from the dataset and return a copy.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of channels to be removed.\n\nReturns FlowCytometryExperiment with the channels not removed.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.removeChannels!","page":"API","title":"FlowCytometry.removeChannels!","text":"function removeChannels!(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove channels from the dataset.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of channels to be removed.\n\nReturns FlowCytometryExperiment with the channels not removed.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.renameControl!","page":"API","title":"FlowCytometry.renameControl!","text":"function renameControl!(fcs::FlowCytometryControl,oldName::String,newName::AbstractString)\n\nChange the name of the a channel in the of a FlowCytometryControl object.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl where to change the name.\noldName::String Old name of the channel.\nnewName::AbstractString New name of the channel.\n\nReturns  Nothing\n\n\n\n\n\nfunction renameControl!(fcs::FlowCytometryControl,dic::Dict{<:AbstractString,<:AbstractString})\n\nChange the name of the channels in the of a FlowCytometryControl object.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl where to change the name.\ndic::Dict{<:AbstractString,<:AbstractString} Dictionary of old names as keys and new names as values.\n\nReturns  Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.checkControlNames","page":"API","title":"FlowCytometry.checkControlNames","text":"function checkControlNames(fcs::FlowCytometryControl)\n\nfunction that checks that the keys of the FlowCytometryControl object correspond to channels defined in .var.channels.\n\nArguemtns\n\nfcs::FlowCytometryControl FlowCytometryControl object where to check if consistent.\n\nReturns  Gives an error if there is any inconsistency.\n\n\n\n\n\n","category":"function"},{"location":"API.html#IO","page":"API","title":"IO","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"loadFCExperiment\nloadFCControls\nsaveH5fcs\nloadH5fcs","category":"page"},{"location":"API.html#FlowCytometry.loadFCExperiment","page":"API","title":"FlowCytometry.loadFCExperiment","text":"function loadFCExperiment(file::String)\n\nFunction that loads a ftc experiment into a FlowCytometryExperiment.\n\nArguments:\n\nfile::String: Path to .ftc file.\n\nReturns:  FlowCytometryExperiment with the data from the uploaded file.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.loadFCControls","page":"API","title":"FlowCytometry.loadFCControls","text":"function loadFCControls(folder::String; control_keyword::String=\"\", inferChannel::Bool=true)\n\nFunction to upload all the files in a folder corresponding to control files.\n\nArguments\n\nfolder::String Address of folder where all the controls are.\n\nKeyword Arguments\n\ncontrol_keyword::String=\"\" String by which to identify control experiment files.\n\nReturns\n\nFlowCytometryControl object with all the controls uploaded. \n\n\n\n\n\nfunction loadFCControls(dic::Dict{String,String})\n\nFunction to upload all the files as given by a dictionary of control files and the corresponding channels.\n\nArguments\n\ndic::Dict{String,String} Disctionary with names of file and name adress assotiated with them.\n\nReturns  FlowCytometryControl object with all the controls uploaded.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.saveH5fcs","page":"API","title":"FlowCytometry.saveH5fcs","text":"function saveH5fcs(fcs::FlowCytometryExperiment,file::String)\n\nFunction to save in .h5fcs a FlowCytometryExperiment.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment to save.\nfile::String File name where to store the data.\n\nReturns Nothing\n\n\n\n\n\nfunction saveH5fcs(fcs::FlowCytometryControl,file::String)\n\nFunction to save in .h5fcs a FlowCytometryControl.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl to save.\nfile::String File name where to store the data.\n\nReturns Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.loadH5fcs","page":"API","title":"FlowCytometry.loadH5fcs","text":"function loadH5fcs(file::String)\n\nFunction to load .h5fcs files into data.\n\nArguments\n\nfile::String File name of the datafile.\n\nReturns FlowCytometryControl or FlowCytometryExperiment loaded from file.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Gating","page":"API","title":"Gating","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Gating.isInsideGate\nGating.manualGating!\nGating.automaticQC!","category":"page"},{"location":"API.html#FlowCytometry.isInsideGate","page":"API","title":"FlowCytometry.isInsideGate","text":"function isInsideGate(p::Tuple{<:Real,<:Real}, gate::FlowCytometryGate)\n\nFunction that given a point and a gate, checks which entries are inside the gate polygon.\n\nArguments:\n\np::Tuple{<:Real,<:Real} Point to check if inside polygon.\ngate::FlowCytometryGate Gate to check if the rows are inside the polygon of the gate.\n\nReturns:  Bool. True entries are the ones inside the gate polygon.\n\n\n\n\n\nfunction isInsideGate(x::Matrix{<:Real}, gate::FlowCytometryGate)\n\nFunction that given the entries of two channels and a gate checks which entries are inside the gate polygon.\n\nArguments:\n\nx::Matrix{<:Real} Matrix with N cells and 2 columns (channels).\ngate::FlowCytometryGate Gate to check if the rows are inside the polygon of the gate.\n\nReturns:  Vector{Bool} with N entries. True entries are the ones inside the gate polygon.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Gating.manualGating!","page":"API","title":"FlowCytometry.Gating.manualGating!","text":"function manualGating!(fcs::FlowCytometryExperiment;debug=false)\n\nLaunch an interactive page accessible at localhost to define gates manually.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment object where to define the gates.\n\nReturns  Nothing. Adds or removes the gates to the object in place.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Gating.automaticQC!","page":"API","title":"FlowCytometry.Gating.automaticQC!","text":"function automaticQC!(fcs::FlowCytometryExperiment;\n    channel1=\"FSC-A\",channel2=\"SSC-A\",\n    trim::Tuple{<:Real,<:Real}=(0.01,0.99),\n    maxtrim::Real=.05,\n    densityBandwidth::Tuple{<:Real,<:Real}=(.1,.05),\n    hullBandwidth=.03,\n    hullBorderFromMax=.3,\n    keyAdded=\"automaticQC\",\n    flavor=\"gaussian\")\n\nFunction that automatically detects the main peak corresponding to viable cells in a FCS/SSC scatterplot and adds a gate to the object.  The method follows the heuristics of Roca et al with some small adaptations.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment where to compute the gate\n\nKeyword arguments\n\nchannel1=\"FSC-A\" Channel name in channels corrresponding to the forwad scatter\nchannel2=\"SSC-A\" Channel name in channels corrresponding to the forwad scatter\ntrim::Tuple{<:Real,<:Real}=(0.01,0.99) Window of used cells in the channel ranges before finding maximums.\nmaxtrim::Real=.05 Minimum in the range channels where to accept maximum points. This avoids the peak pressent in some datasets at lower expressions (debris).\ndensityBandwidth::Tuple{<:Real,<:Real}=(.1,.05) Bandwidth as proportion of the total range to smooth the data before finding peaks.\nhullBandwidth=.03 Bandwidth as proportion of the total range to smooth the data before finding the hull neighborhood. Only used if flavor = \"classic\".\nhullBorderFromMax=.3 Heigh from global maximum. Points with more probability that that will be used to make the hull.\nkeyAdded=\"automaticQC\" Key added to uns and gate name.\nflavor=\"gaussian\" Flavor of the algorithm. Choose between \"gaussian\" or \"classic\", that corresponds to the implementation from the original paper.\n\nReturns Nothing. A gate of automatic control is added to gates.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Compensation-(Spillover/Unmixing)","page":"API","title":"Compensation (Spillover/Unmixing)","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Compensation.computeCompensationMatrix!\nCompensation.compensate!\nCompensation.assignCompensation!","category":"page"},{"location":"API.html#FlowCytometry.Compensation.computeCompensationMatrix!","page":"API","title":"FlowCytometry.Compensation.computeCompensationMatrix!","text":"function computeCompensationMatrix!(fcs::FlowCytometryControl; error::AbstractFloat = 10E-5, nMaxiterations::Int=10)\n\nCompute the compensation matrix as proposed by Roca et al.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl where to compute the spillover matrix.\n\nKeyword arguments\n\nerror::AbstractFloat = 10E-5 Maximum error to stop the refinement of the spillover matrix.\nnMaxIterations::Int=10 Maximum number of iterations of the refinement matrix. Set to 0 to compute the classical spillover matrix.\n\nResults  Nothing. Adds the compensation matrix to the FlowCytometryControl object.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Compensation.compensate!","page":"API","title":"FlowCytometry.Compensation.compensate!","text":"function compensate!(fcs::FlowCytometryControl)\n\nCompensate all the control experiments with the compensationMatrix of the object\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl object where to compute the compensation.\n\nReturns Nothing\n\n\n\n\n\nfunction compensate!(fcs::FlowCytometryExperiment)\n\nCompensate FlowCytometryExperiment experiment with an assigned compensationMatrix from a FlowCytometryControl object. See assignCompensation!.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment object where to compute the compensation.\n\nReturns Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Compensation.assignCompensation!","page":"API","title":"FlowCytometry.Compensation.assignCompensation!","text":"function assignCompensation!(fcs::FlowCytometryExperiment;control::FlowCytometryControl)\n\nAssign a compensation mattrix to a FlowCytometryExperiment experiment from the compensationMatrix of a FlowCytometryControl object.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment object where to compute the compensation.\n\nKeyword Arguments\n\ncontrol::FlowCytometryControl FlowCytometryControl to use the compensationMatrix\n\nReturns Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#Dimensionaity-reduction","page":"API","title":"Dimensionaity reduction","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"DimensionalityReduction.pca!\nDimensionalityReduction.umap!","category":"page"},{"location":"API.html#FlowCytometry.DimensionalityReduction.pca!","page":"API","title":"FlowCytometry.DimensionalityReduction.pca!","text":"function pca!(fct::FlowCytometryExperiment;\n    maxoutdim::Int = 0,\n    method::Symbol = :auto,\n    variance_ratio::Float64 = 0.99,\n    mean = nothing,\n    key_added::String = \"pca\",\n    key_used_channels::Union{Nothing,String} = nothing\n    )\n\nPerform pca analysis over the channels.\n\nArguments:\n\nfct::FlowCytometryExperiment FlowCytometryExperiment to perform the pca.\n\nKeyword Arguments\n\nmaxoutdim = 0 Number of PCS to compute if 0, it will compute NChannels-1\nmethod = :auto Method to compute pca. Choose between :svd, :cov and :auto.\nvariance_ratio = 0.99 Variance ratio up to which compute pca.\nmean = nothing If to consider the normalization as performed. nothing will consider the mean not adjusted.\nkey_added::String = \"pca\" Key to be added to object.\nkeyusedchannels::Union{Nothing,String} = nothing Bool column from .var specifying which channels to use for clustering.\n\nReturns  Nothing. To the FlowCytometryExperiment object provided, PCs are added to the .obsm[keyadded] and information of the algorithm if included in .uns[keyadded].\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.DimensionalityReduction.umap!","page":"API","title":"FlowCytometry.DimensionalityReduction.umap!","text":"function umap!(fct::FlowCytometryExperiment;\n    n_dims::Int = 2,\n    key_added::String = \"umap\",\n    key_obsm::Union{Nothing,String} = nothing,\n    n_components::Union{Nothing,Int} = nothing,\n    key_used_channels::Union{Nothing,String} = nothing,\n    kwargs...\n    )\n\nFunction that computes the UMAP plot of the neighbors.\n\nArguments\n\nfct::FlowCytometryExperiment FlowCytometryExperiment to perform the UMAP.\n\nKeyword Arguments\n\nn_dims::Int = 2 Number of dimensions for the projection.\nkey_added::String = \"KMeans\" Key to be added to object.\nkey_obsm::Union{Nothing,String} = nothing Matrix in .obsm to use for the clustering. Only keyobsm or keyused_channels can be specified.\nn_components::Union{Nothing,Int} = nothing Number of components to use from the .obsm.\nkeyusedchannels::Union{Nothing,String} = nothing Bool column from .var specifying which channels to use for clustering.\nkwargs... Keyword argumetns for the UMAP_ function. Do ?FlowCytometry.UMAP_ for more details on the keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Clustering","page":"API","title":"Clustering","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"<!– Clustering.kmeansTuning Clustering.agglomerative! –>","category":"page"},{"location":"API.html","page":"API","title":"API","text":"Clustering.kmeans!\nClustering.gaussianMixture!","category":"page"},{"location":"API.html#FlowCytometry.Clustering.kmeans!","page":"API","title":"FlowCytometry.Clustering.kmeans!","text":"function kmeans!(fct::FlowCytometryExperiment;\n    k::Int = 2, \n    metric = Distances.SqEuclidean(0.0),\n    init::Symbol = :kmpp,\n    key_added::String = \"kmeans\",\n    key_obsm::Union{Nothing,String} = nothing,\n    n_components::Union{Nothing,Int} = nothing,\n    key_used_channels::Union{Nothing,String} = nothing)\n\nFunction that clusters the data using the KMeans algorithm. To help asses the number of clusters you can use KMeansTuning function.\n\nArguments\n\nfct::FlowCytometryExperiment FlowCytometryExperiment to cluster the data.\n\nKeyword Arguments\n\nk::Int Number of clusters to partition the data.\nmetric = Distances.SqEuclidean(0.0) Metric to compute distances. \ninit::Symbol = :kmpp Initialisation algorithm of the KMeans. Choose between :kmpp, :rand or :kmenc. ?Clustering.kmeans_ for more information.\nkey_added::String = \"KMeans\" Key to be added to object.\nkey_obsm::Union{Nothing,String} = nothing Matrix in .obsm to use for the clustering. Only keyobsm or keyused_channels can be specified.\nn_components::Union{Nothing,Int} = nothing Number of components to use from the .obsm.\nkey_used _channels::Union{Nothing,String} = nothing Bool column from .var specifying which channels to use for clustering.\n\nReturns  Nothing. To the FlowCytometryExperiment object provided, clusters identities are added to the .obs[keyadded] and information of the algorithm if included in .uns[keyadded].\n\n\n\n\n\n","category":"function"}]
}
