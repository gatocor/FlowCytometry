var documenterSearchIndex = {"docs":
[{"location":"References.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"References.html","page":"References","title":"References","text":"[1]  M. Dundar, F. Akova, H. Z. Yerebakan, and B. Rajwa, “A non-parametric Bayesian model for joint cell clustering and cluster matching: identification of anomalous sample phenotypes with random effects,” BMC Bioinformatics, vol. 15, no. 1, p. 314, Sep. 2014, doi: 10.1186/1471-2105-15-314.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[2] C. P. Roca et al., “AutoSpill is a principled framework that simplifies the analysis of multichromatic flow cytometry data,” Nat Commun, vol. 12, no. 1, Art. no. 1, May 2021, doi: 10.1038/s41467-021-23126-8.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[3] Y. Saeys, S. Van Gassen, and B. N. Lambrecht, “Computational flow cytometry: helping to make sense of high-dimensional immunology data,” Nat Rev Immunol, vol. 16, no. 7, Art. no. 7, Jul. 2016, doi: 10.1038/nri.2016.56.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[4] N. Aghaeepour et al., “Critical assessment of automated flow cytometry data analysis techniques,” Nat Methods, vol. 10, no. 3, Art. no. 3, Mar. 2013, doi: 10.1038/nmeth.2365.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[5] A. J. Cron and M. West, “Efficient Classification-Based Relabeling in Mixture Models,” Am Stat, vol. 65, no. 1, pp. 16–20, Feb. 2011, doi: 10.1198/tast.2011.10170.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[6] D. Novo, G. Grégori, and B. Rajwa, “Generalized unmixing model for multispectral flow cytometry utilizing nonsquare compensation matrices,” Cytometry Part A, vol. 83A, no. 5, pp. 508–520, 2013, doi: 10.1002/cyto.a.22272.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[7] L. Velten et al., “Human haematopoietic stem cell lineage commitment is a continuous process,” Nat Cell Biol, vol. 19, no. 4, Art. no. 4, Apr. 2017, doi: 10.1038/ncb3493.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[8] T. Sörensen, S. Baumgart, P. Durek, A. Grützkau, and T. Häupl, “immunoClust—An automated analysis pipeline for the identification of immunophenotypic signatures in high-dimensional cytometric datasets,” Cytometry Part A, vol. 87, no. 7, pp. 603–615, 2015, doi: 10.1002/cyto.a.22626.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[9] A. Mercuri et al., “Immunophenotypic analysis of hematopoiesis in patients suffering from Shwachman–Bodian–Diamond Syndrome,” European Journal of Haematology, vol. 95, no. 4, pp. 308–315, 2015, doi: 10.1111/ejh.12490.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[10] I. P. Sugár and S. C. Sealfon, “Misty Mountain clustering: application to fast unsupervised flow cytometry gating,” BMC Bioinformatics, vol. 11, p. 502, Oct. 2010, doi: 10.1186/1471-2105-11-502.","category":"page"},{"location":"References.html","page":"References","title":"References","text":"[11] L. Ferrer‐Font, C. Pellefigues, J. U. Mayer, S. J. Small, M. C. Jaimes, and K. M. Price, “Panel Design and Optimization for High‐Dimensional Immunophenotyping Assays Using Spectral Flow Cytometry,” Current Protocols in Cytometry, vol. 92, no. 1, Mar. 2020, doi: 10.1002/cpcy.70.","category":"page"},{"location":"autofluorescence/autofluorescence.html#Autofluorescence-compensation","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"","category":"section"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"In here we explain how to perform channel compensation. We reproduce in this scrip Figure 2 from Roca et all (2021).","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"The dataset employed in this example is:","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"HS1","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"using FlowCytometry\nusing Plots\nusing DataFrames\nusing CSV","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"┌ Info: Precompiling FlowCytometry [dda4a566-a714-4635-9e97-d7f3f719a55d]\n└ @ Base loading.jl:1342","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"<div style=\"padding: 1em; background-color: #f8d6da; border: 1px solid #f5c6cb; font-weight: bold;\"> <p>The WebIO Jupyter extension was not detected. See the <a href=\"https://juliagizmos.github.io/WebIO.jl/latest/providers/ijulia/\" target=\"_blank\">     WebIO Jupyter integration documentation </a> for more information. </div>","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"data = CSV.read(\"FlowRepository_FR-FCM-Z2ST_files/attachments/fcs_control_hs1.csv\",DataFrame)\ndic = Dict([string(\"FlowRepository_FR-FCM-Z2ST_files/\",i)=>string(j) for (i,j) in eachrow(data[:,[\"filename\",\"dye\"]])])","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"Dict{String, String} with 23 entries:\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BV605-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BB630-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"PE-Cy5.5-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BUV805-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BV480-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"APC-H7-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BV421-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BUV615-P-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BUV737-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BYG584-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BB660-P-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BYG790-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"APC-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BV650-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BV786-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BV750-P-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BUV496-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"PE-CF594-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BB700-P-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BYG670-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 P… => \"BV570-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"BV711-A\"\n  \"FlowRepository_FR-FCM-Z2ST_files/Single color controls CD4_C… => \"FITC-A\"","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"fcsWOAutofluorescence = loadFCControls(dic);\nchannelsCompensate = data[:,\"dye\"];\nCompensation.computeCompensationMatrix!(fcsWOAutofluorescence,channelsCompensate=channelsCompensate)","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"Not all control files have the same number of channels. These channels will not be compensated for controls that does not have them.\n Channels not present in all files: Any[\"FSC-W\", \"SSC-H\", \"SSC-W\"]\n\n\n\u001b[32mComputing S(0)... 100%|██████████████████████████████████| Time: 0:00:08\u001b[39m\n\u001b[32mRefinement Iterations... 100%|███████████████████████████| Time: 0:00:01\u001b[39m","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"data = CSV.read(\"FlowRepository_FR-FCM-Z2ST_files/attachments/fcs_control_hs1_autofluorescence_correction.csv\",DataFrame)\ndic = Dict([string(\"FlowRepository_FR-FCM-Z2ST_files/\",i)=>string(j) for (i,j) in eachrow(data[:,[\"filename\",\"dye\"]])])\n\nfcsWAutofluorescence = loadFCControls(dic);\nchannelsCompensate = data[:,\"dye\"];\nCompensation.computeCompensationMatrix!(fcsWAutofluorescence,channelsCompensate=channelsCompensate)","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"Not all control files have the same number of channels. These channels will not be compensated for controls that does not have them.\n Channels not present in all files: Any[\"FSC-W\", \"SSC-H\", \"SSC-W\"]\n\n\n\u001b[32mComputing S(0)... 100%|██████████████████████████████████| Time: 0:00:01\u001b[39m\n\u001b[32mRefinement Iterations... 100%|███████████████████████████| Time: 0:00:02\u001b[39m","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"f = FCSPloting.plotControls(fcsWAutofluorescence,\n    [\n        (\"FITC-A\",\"BUV563-A\",\"BUV615-P-A\"),(\"FITC-A\",\"BUV563-A\",\"BUV737-A\"),\n        (\"BUV496-A\",\"BUV496-A\",\"BUV615-P-A\"),(\"BUV805-A\",\"BUV805-A\",\"BUV615-P-A\"),\n        ])\n\nf2 = FCSPloting.plotControls(fcsWOAutofluorescence,\n    [\n        (\"BUV496-A\",\"BUV496-A\",\"BUV615-P-A\"),(\"BUV805-A\",\"BUV805-A\",\"BUV615-P-A\"),\n        ])\n\nfs = [plot(fig,title=title) for (fig,title) in zip([f;f2],[\"autofluorescence\",\"autofluorescence\",\"with autofluorescence\",\"with autofluorescence\",\"without autofluorescence\",\"without autofluorescence\"])]\nplot(fs..., layout = (3,2), fmt=:png, size=(1000,1000))","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"(Image: png)","category":"page"},{"location":"autofluorescence/autofluorescence.html","page":"Autofluorescence compensation","title":"Autofluorescence compensation","text":"Compensation.compensate!(fcsWAutofluorescence)","category":"page"},{"location":"gating/gating.html#Automatic-Quality-Control","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"","category":"section"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"In here we explain how to perform automatic gating inside the pipeline. We reproduce in this scrip Figure 1 from Roca et all (2021).","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"The datasets employed in this example are:","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"MM1\nHS1 & HS2\nBe1","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"using FlowCytometry\nusing Plots","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"<div style=\"padding: 1em; background-color: #f8d6da; border: 1px solid #f5c6cb; font-weight: bold;\"> <p>The WebIO Jupyter extension was not detected. See the <a href=\"https://juliagizmos.github.io/WebIO.jl/latest/providers/ijulia/\" target=\"_blank\">     WebIO Jupyter integration documentation </a> for more information. </div>","category":"page"},{"location":"gating/gating.html#Loading-data","page":"Automatic Quality Control","title":"Loading data","text":"","category":"section"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"fcsMM1 = loadFCExperiment(\"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC Stained Control_006.fcs\")\nfcsHS1 = loadFCExperiment(\"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 PANEL_CD45RA FITC_047.fcs\")\nfcsHS2 = loadFCExperiment(\"FlowRepository_FR-FCM-Z2ST_files/Single color controls ST1 PANEL_CD14 PECY55_050.fcs\")\nfcsBe1 = loadFCExperiment(\"FlowRepository_FR-FCM-Z2SV_files/Compensation Controls_APC Stained Control_007.fcs\");","category":"page"},{"location":"gating/gating.html#Computing-automatic-QC-gates","page":"Automatic Quality Control","title":"Computing automatic QC gates","text":"","category":"section"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"The algorithm employed in Roca et all (2021). For most part of the datasets, the parameters are robust and we will not need to change them. The most relevant parameters are:","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"trim=(0.01,0.99) Percentile range in the channel ranges to use in the analysis before finding maximums.\nmaxtrim=.05 Minimum in the range channels where to accept maximum points. This avoids the peak present in some datasets at lower expressions (debris).\ndensityBandwidth=(.5,.3) Relative bandwidth to smooth the density plots.\nfinalBandwidth=.1 Relative bandwidth to smooth the density plots in the final step.\nheightFromMax=.3 In the last step, heigh at global maximum where to draw the contour of the QC region. Points with more probability that that will be used to make the QC gate.\nsubsample=2000 Subsample of points used for density steps of the system. Set to 'nothing' for using all the points (this can be extremely slow), with relative low numbers of points the gate output are already very good.","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"We can directly apply the algorithm for the datasets from above:","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"Gating.automaticQC!(fcsMM1);\nGating.automaticQC!(fcsHS1,maxtrim=0.15); #We choose a higher maxtrim to avoid the maximum at very low counts that appear in this dataset and that is probably debris\nGating.automaticQC!(fcsHS2,maxtrim=0.15); #We choose a higher maxtrim to avoid the maximum at very low counts that appear in this dataset and that is probably debris\nGating.automaticQC!(fcsBe1);","category":"page"},{"location":"gating/gating.html#Visualize-results-of-QC","page":"Automatic Quality Control","title":"Visualize results of QC","text":"","category":"section"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"Finally we can see the results from the pipeline.","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"f1 = FCSPloting.plotQCSteps(fcsMM1)\nf2 = FCSPloting.plotQCSteps(fcsHS1)\nf3 = FCSPloting.plotQCSteps(fcsHS2)\nf4 = FCSPloting.plotQCSteps(fcsBe1)\n\nf = plot(\nf1,\nf2,\nf3,\nf4,\nlayout=(4,1), fmt=:png, size=(2000,1500)\n    )","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"(Image: png)","category":"page"},{"location":"gating/gating.html#Gate-the-cells-and-remove-cell-that-are-not-is-our-interest","page":"Automatic Quality Control","title":"Gate the cells and remove cell that are not is our interest","text":"","category":"section"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"Finally we can remove cells that are not of use.","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"Gating.filterByGate!(fcsMM1,\"automaticQC\")\nGating.filterByGate!(fcsHS1,\"automaticQC\")\nGating.filterByGate!(fcsHS2,\"automaticQC\")\nGating.filterByGate!(fcsBe1,\"automaticQC\")","category":"page"},{"location":"gating/gating.html","page":"Automatic Quality Control","title":"Automatic Quality Control","text":"removeCells!(fcsMM1,fcsMM1.obs[:,\"automaticQC_gate\"])\nremoveCells!(fcsHS1,fcsHS1.obs[:,\"automaticQC_gate\"])\nremoveCells!(fcsHS2,fcsHS2.obs[:,\"automaticQC_gate\"])\nremoveCells!(fcsBe1,fcsBe1.obs[:,\"automaticQC_gate\"])","category":"page"},{"location":"usage/usage.html#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"We are going over the main functionality of the FlowCytometry package.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"For this tutorial you will need to have installed the following packages:","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"FlowCytometry \nPlots for the visualization of the results\nCSV for uploading files\nDataFrames as storage ","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"First we upload the required packages.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"using FlowCytometry\nusing PyPlot\nusing CSV\nusing DataFrames","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"┌ Info: Precompiling FlowCytometry [dda4a566-a714-4635-9e97-d7f3f719a55d]\n└ @ Base loading.jl:1342\nWARNING: Method definition compensate!(FlowCytometry.FlowCytometryExperiment) in module Compensation at /home/gabriel/Documents/FlowCytometry/src/compensation.jl:155 overwritten at /home/gabriel/Documents/FlowCytometry/src/compensation.jl:188.\n  ** incremental compilation may be fatally broken for this module **\n\n\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mReplacing docs for `FlowCytometry.Compensation.compensate! :: Tuple{FlowCytometry.FlowCytometryExperiment}` in module `FlowCytometry.Compensation`\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ Base.Docs docs/Docs.jl:240\u001b[39m","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"<div style=\"padding: 1em; background-color: #f8d6da; border: 1px solid #f5c6cb; font-weight: bold;\"> <p>The WebIO Jupyter extension was not detected. See the <a href=\"https://juliagizmos.github.io/WebIO.jl/latest/providers/ijulia/\" target=\"_blank\">     WebIO Jupyter integration documentation </a> for more information. </div>","category":"page"},{"location":"usage/usage.html#Basics-of-the-FlowCytometry.jl-structures","page":"Usage","title":"Basics of the FlowCytometry.jl structures","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"The Flow cytometry package works around a few structures that help with the upload and manipulation of flow cytometry data.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"The basic structure is FlowCytometryExperiment. The structure follows a very similar struture to the AnnData object for scRNA seq analysis of Scanpy.","category":"page"},{"location":"usage/usage.html#Loading","page":"Usage","title":"Loading","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"We can construct it manually starting from a measures matrix. Let's make a initialization of experiment with 100 cells and 10 channels.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcs = FlowCytometryExperiment(rand(100,10));","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Alternatively, we can directly load a fcs experiment.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcs = loadFCExperiment(\"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC Stained Control_006.fcs\");","category":"page"},{"location":"usage/usage.html#Accesing-the-properties","page":"Usage","title":"Accesing the properties","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"The structure contains several properties useful for the analysis.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"X Matrix of Cells X Channel of the experiment.\nobs Dataframe with all the metainformation of the cells\nvar Dataframe with all the metainformation of the channels\nobsm Dictionary containing transformed matrices of the original data.\nlayers Dictionary containing Cells X Channel matrices of data that are required to control (e.g. Raw matrix).\ngates List of Gate and Gate set objects\nuns Dictionary contining all the metainformation of algorithms applied to the data.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"The data uploaded before contains for now a matrix with 5000 cells and 35 channels.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcs.X","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"The experiment metainformation has been stored in .uns[\"ExperimentInformation\"].","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcs.uns[\"ExperimentInformation\"]","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"And we have the name of the channels in .channels.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcs.channels","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"It is useful to note than the channels can be accessed directly by calling directly to the FlowCytometryExperiment object as fcs[channel_of_interest]. Let's use this property for ploting a scatterplot of two channels.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fig, ax = subplots(1,1)\nax.scatter(fcs[\"APC-A\"],fcs[\"APC-R700-A\"],s=10)\nax.set_xlabel(\"APC-R700-A\")\nax.set_ylabel(\"APC-A\")\nax.set_title(\"Control experiment APC Dye\")","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"We can already see from this data the spillover effect of APC-A to APC-R700-A.","category":"page"},{"location":"usage/usage.html#Gating","page":"Usage","title":"Gating","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Flow compensation usually requires of quality control of the cells and measures change in proportion of cells between experimennts to see if there is changes in the number of cells present in specific regions of the channel space.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"We can define gates for our experiment in several ways.","category":"page"},{"location":"usage/usage.html#Manual-gating","page":"Usage","title":"Manual gating","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"We can define a manual gates by calling the function Gating.manualGating!. This will start an app that can be accessed in any browser by writing localhost::channel, for the channel prompted by the function. When desiring to stop adding gates, you will have just to kill the app with ctr+C or similar and the gates will be added to the FlowCytometryExperiment object.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Gating.manualGating!(fcs)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"When calling the function, in the browser you will see a page like this:","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"(Image: )","category":"page"},{"location":"usage/usage.html#Automatic-gating","page":"Usage","title":"Automatic gating","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"using Statistics, LinearAlgebra","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"det(cov(rand(20,20)))","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"mean(rand(4,5),dims=1)[1,:]","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"automaticQC!(fcs)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fig,ax = subplots(1,5,figsize=[25,3])\n\nax[1].fill([i[1] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],[i[2] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],alpha=0.5,zorder=-1,color=\"lightBlue\")\nax[1].scatter(fcs[\"FSC-A\"],fcs[\"SSC-A\"],s=2)\n\nax[2].fill([i[1] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],[i[2] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],alpha=0.5,zorder=-1,color=\"lightBlue\")\nax[2].fill([i[1] for i in fcs.uns[\"automaticQC\"][\"Step2_ExcludeMaximums\"]],[i[2] for i in fcs.uns[\"automaticQC\"][\"Step2_ExcludeMaximums\"]],alpha=0.5,zorder=-1,color=\"orange\")\nax[2].scatter(fcs[\"FSC-A\"],fcs[\"SSC-A\"],c=fcs.obs[:,\"automaticQC_density1\"],cmap=\"Spectral_r\",s=2)\nax[2].scatter(fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][1],fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][2],color=\"k\",s=50)\nax[2].scatter([fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][1]],[fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][2]],color=\"orange\",s=50)\n\nax[3].fill([i[1] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],[i[2] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],alpha=0.5,zorder=-1,color=\"lightBlue\")\nax[3].fill([i[1] for i in fcs.uns[\"automaticQC\"][\"Step5_Tesselation\"]],[i[2] for i in fcs.uns[\"automaticQC\"][\"Step5_Tesselation\"]],alpha=0.5,zorder=-1,color=\"orange\")\nax[3].scatter(fcs[\"FSC-A\"],fcs[\"SSC-A\"],c=fcs.obs[:,\"automaticQC_density1\"],cmap=\"Spectral_r\",s=2)\nax[3].scatter(fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][1],fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][2],color=\"k\",s=50)\nax[3].scatter([fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][1]],[fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][2]],color=\"orange\",s=50)\n\nax[4].fill([i[1] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],[i[2] for i in fcs.uns[\"automaticQC\"][\"Step1_TrimOutliers\"]],alpha=0.5,zorder=-1,color=\"lightBlue\")\nax[4].fill([i[1] for i in fcs.uns[\"automaticQC\"][\"Step6_Rectangle\"]],[i[2] for i in fcs.uns[\"automaticQC\"][\"Step6_Rectangle\"]],alpha=0.5,zorder=-1,color=\"orange\")\nax[4].scatter(fcs[\"FSC-A\"],fcs[\"SSC-A\"],c=fcs.obs[:,\"automaticQC_density1\"],cmap=\"Spectral_r\",s=2)\nax[4].scatter(fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][1],fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][2],color=\"k\",s=50)\nax[4].scatter([fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][1]],[fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][2]],color=\"orange\",s=50)\n\nax[5].fill([i[1] for i in fcs.gates[\"automaticQC\"].polygon],[i[2] for i in fcs.gates[\"automaticQC\"].polygon],alpha=1,facecolor=\"none\",edgecolor=\"red\")\nax[5].scatter(fcs[\"FSC-A\"],fcs[\"SSC-A\"],c=fcs.obs[:,\"automaticQC_density1\"],cmap=\"Spectral_r\",s=2)\nax[5].scatter(fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][1],fcs.uns[\"automaticQC\"][\"Step3_LocalMaximums\"][2],color=\"k\",s=50)\nax[5].scatter([fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][1]],[fcs.uns[\"automaticQC\"][\"Step4_GlobalMaximum\"][2]],color=\"orange\",s=50)\n\nfor a in ax\n    a.set_xlim(0,30E4)\n    a.set_ylim(0,30E4)\n    a.set_xticks([0,30E4])\n    a.set_yticks([0,30E4])\nend\n","category":"page"},{"location":"usage/usage.html#Compensation","page":"Usage","title":"Compensation","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Most part of flow cytometry experiments use several signaling channels. Some of the most common experimental as flow cytometry or spectral cytometry suffer from spillover/mixing of the information among the channels. To correct this behavior and having uncoupled signals, one-fluorophore control experiments are performed in order to compute what is called the compensation matrice to uncouple the channels.","category":"page"},{"location":"usage/usage.html#Loading-control-experiments","page":"Usage","title":"Loading control experiments","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"We can upload the control experiments in a special structure named FlowCytometryControl, that is more less a container of diferent FlowCytometryExperiment. Each control experiment is assigned a channel that corresponds to the maximum peack of its spectrum. This is very important to when computing the compensation matrix. The best way of uploading the data is by assigning the different control files to the according channels.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"In this example we have a file that has already this assignation:","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"controls = CSV.read(\"FlowRepository_FR-FCM-Z2SS_files/attachments/fcs_control.csv\",FlowCytometry.DataFrame)\nprint(controls[1:5,:])","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"We will construct a dictionary assigning file to channel.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fileChannelAssignation = Dict([string(\"FlowRepository_FR-FCM-Z2SS_files/\",i)=>String(j) for (i,j) in eachrow(controls[:,[\"filename\",\"dye\"]])])","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Now we can load the data.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcsControl = loadFCControls(fileChannelAssignation);","category":"page"},{"location":"usage/usage.html#Compute-compensation-matrix","page":"Usage","title":"Compute compensation matrix","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"With the data uploaded we can compute the compensation matrix from the FlowCytometryControl object.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Compensation.computeCompensationMatrix!(fcsControl)","category":"page"},{"location":"usage/usage.html#Compensate-datasets","page":"Usage","title":"Compensate datasets","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"With the compensated matrix computed, we can compensate the data. There are several methods of proceeding with the compensation.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Compensate the control data","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"experimentUncompensated = deepcopy(fcsControl.controls[\"APC-A\"]) #Make a copy before compensation\nCompensation.compensate!(fcsControl)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Now we can visualize the results of the compensation and see that it has been correctly compensated.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"experiment = fcsControl.controls[\"APC-A\"]\nscatter(experimentUncompensated[\"APC-A\"],experimentUncompensated[\"APC-R700-A\"],label=\"Not compensated\")\nscatter!(experiment[\"APC-A\"],experiment[\"APC-R700-A\"],label=\"Compensated\",xlabel=\"APC-A\",ylabel=\"APC-R700-A\",title=\"Control APC-A\")\nxlabel!(\"APC-A\")\nylabel!(\"APC-R700-A\")","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Compensate the a FlowCytometryExperiment object with a FlowCytometryControl object","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcsCopy = deepcopy(fcs)\nCompensation.compensate!(fcsCopy,control=fcsControl)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Assign the compensation matrix of a FlowCytometryControl to a FlowCytometryExperiment and then compensate.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"fcsCopy = deepcopy(fcs)\nCompensation.assignCompensation!(fcsCopy,control=fcsControl)\nCompensation.compensate!(fcsCopy)","category":"page"},{"location":"usage/usage.html#Dimensionality-reduction","page":"Usage","title":"Dimensionality reduction","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"In some datasets, the data is very high dimensional and visualizing all pairwise steps may not be possible or hard to interpret. For that reason, we can apply several dimensionality reduction methods to summarize the data.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Let's see that by constructing a toy dataset with two cell types. This data doesn't show well separated by any particular plot in of two of the variables. However, PCA analysis or UMAP projection are able to show the separation between the two clusters.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"All this visualizations are stored as transformations of the original data in .obms.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"X = [randn(1000,10); (randn(1000,10).+[0 2 0 2 0 2 0 2 0 0])];\nfcs = FlowCytometryExperiment(X);","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"DimensionalityReduction.pca!(fcs)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"DimensionalityReduction.umap!(fcs)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"plot(scatter(fcs[\"1\"],fcs[\"2\"],title=\"Variables\"),\n    scatter(fcs.obsm[\"pca\"][:,1],fcs.obsm[\"pca\"][:,2],title=\"PC\"),\n    scatter(fcs.obsm[\"umap\"][:,1],fcs.obsm[\"umap\"][:,2],title=\"UMAP\"),\n    layout=(1,3),legend=false,size=[1200,400])","category":"page"},{"location":"usage/usage.html#Clustering","page":"Usage","title":"Clustering","text":"","category":"section"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"One of the main uses of cytometry data is to cluster data by cell types. Several methods are already implemented in the package. Resuing the toy model before.","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Clustering.kmeans!(fcs,n_components=2)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Clustering.agglomerative!(fcs,n_components=2)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"plot(scatter(fcs.obsm[\"pca\"][:,1],fcs.obsm[\"pca\"][:,2],markercolor=Array(fcs.obs[:,\"kmeans\"]),title=\"KMeans\"),\n    scatter(fcs.obsm[\"pca\"][:,1],fcs.obsm[\"pca\"][:,2],markercolor=Array(fcs.obs[:,\"agglomerative\"]),title=\"Agglomerative\"),\n    layout=(1,2),legend=false,size=[800,400])","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"using Distributions","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"c = [.1 .01 .01;.01 .1 .02;.01 .02 .2]\nX = permutedims(rand(MultivariateNormal([0,1,2],c),1000));\nY = permutedims(rand(MultivariateNormal([0,3,2],c),1000));\nfcs = FlowCytometryExperiment([X;Y]);","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"Clustering.gaussianMixture!(fcs,k=3,initialization=\"kmeans\",verbose=true)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:00:03\u001b[39m\n\u001b[34m  iter:  2000\u001b[39m","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"plot(fcs.uns[\"gaussianMixture\"][\"means\"][:,1,2])\nplot(fcs.uns[\"gaussianMixture\"][\"means\"][:,2,2])\nplot(fcs.uns[\"gaussianMixture\"][\"means\"][:,3,2])","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"(Image: png)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"1-element Vector{PyCall.PyObject}:\n PyObject <matplotlib.lines.Line2D object at 0x7f3aad1677f0>","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"for i in 1:3\n    plot(fcs.uns[\"gaussianMixture\"][\"weights\"][:,i])\nend","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"(Image: png)","category":"page"},{"location":"usage/usage.html","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"compensation/compensation.html#Compensation","page":"Compensation","title":"Compensation","text":"","category":"section"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"In here we explain how to perform channel compensation. We reproduce in this scrip Figure 2 from Roca et all (2021).","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"The dataset employed in this example is:","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"MM1","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"using FlowCytometry\nusing CSV\nusing DataFrames\nusing Plots","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"data = CSV.read(\"FlowRepository_FR-FCM-Z2SS_files/attachments/fcs_control.csv\",DataFrame)\ndic = Dict([string(\"FlowRepository_FR-FCM-Z2SS_files/\",i)=>string(j) for (i,j) in eachrow(data[:,[\"filename\",\"dye\"]])])","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"Dict{String, String} with 28 entries:\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BYG79… => \"BYG790-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV786… => \"BV786-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV80… => \"BUV805-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV605… => \"BV605-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV650… => \"BV650-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB660… => \"BB660-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB700… => \"BB700-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV73… => \"BUV737-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV750… => \"BV750-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC S… => \"APC-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB790… => \"BB790-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC-R… => \"APC-R700-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV570… => \"BV570-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_PE-CF… => \"PE-CF594-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_FITC … => \"FITC-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV421… => \"BV421-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BB630… => \"BB630-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BYG58… => \"BYG584-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV480… => \"BV480-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV49… => \"BUV496-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BYG67… => \"BYG670-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_APC-H… => \"APC-H7-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV61… => \"BUV615-P-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BUV39… => \"BUV395-A\"\n  \"FlowRepository_FR-FCM-Z2SS_files/Compensation Controls_BV711… => \"BV711-A\"\n  ⋮                                                              => ⋮","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"fcsMM1 = loadFCControls(d);","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"channelsCompensate = data[:,\"dye\"];","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"Compensation.computeCompensationMatrix!(fcsMM1,channelsCompensate=channelsCompensate)","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"f = FCSPloting.plotControls(fcsMM1,[(\"APC-R700-A\",\"APC-R700-A\",\"APC-A\"),(\"BB700-P-A\",\"BB700-P-A\",\"BUV737-A\"),(\"BB630-A\",\"BB630-A\",\"BUV615-P-A\"),(\"BV480-A\",\"BV480-A\",\"BV650-A\")])\n\nplot(f..., layout = (2,2), fmt=:png, size=(1000,1000))","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"(Image: png)","category":"page"},{"location":"compensation/compensation.html","page":"Compensation","title":"Compensation","text":"Compensation.compensate!(fcsMM1)","category":"page"},{"location":"index.html#FlowCytometry.jl-Documentation","page":"Home","title":"FlowCytometry.jl Documentation","text":"","category":"section"},{"location":"API.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"API.html#Basic-Structures","page":"API","title":"Basic Structures","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"FlowCytometryGate\nFlowCytometryControl\nFlowCytometryExperiment","category":"page"},{"location":"API.html#FlowCytometry.FlowCytometryGate","page":"API","title":"FlowCytometry.FlowCytometryGate","text":"struct FlowCytometryGate\n\nStructure that contains information from a gating process of the data.\n\nElements:\n\nchannels::Tuple{String,String} Channel names of the gate.\npolygon::Vector{Tuple{Real,Real}} Points of poligon that defines the gate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#FlowCytometry.FlowCytometryControl","page":"API","title":"FlowCytometry.FlowCytometryControl","text":"mutable struct FlowCytometryControl\n\nStructure that stores the data coming from control stainings for correcting for spillover.  In order for the system to compute properly the spillover matrix, the names of the dictionary must correspond with the names in the channel labels in var.\n\nElements:\n\nchannels::Vector{String} Name of the channels in the experiment.\ncontrols::Dict{String,FlowCytometryExperiment} Dictionary of FlowCytometryExperiments containing the control experiments.\ncompensationMatrix::Union{Nothing,CompensationMatrix} Spillover matrix inverted.\nuns::Dict{String,Any} Dictionary where to store metainformation from spillover algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API.html#FlowCytometry.FlowCytometryExperiment","page":"API","title":"FlowCytometry.FlowCytometryExperiment","text":"mutable struct FlowCytometryExperiment\n\nStructure containing a Flow Cytometry experiment and all the processes applyied to it.\n\nElements:   \n\nchannels::Vector{String} Name of the channels in the experiment.\nX::Matrix{AbstractFloat} Matrix of Cells X Channel of the experiment.\nobs::DataFrame Dataframe with all the metainformation of the cells\nvar::DataFrame Dataframe with all the metainformation of the channels\nobsm::Dict{String,Matrix{AbstractFloat}} Dictionary containing transformed matrices of the original data.\nlayers::Dict{String,Matrix{AbstractFloat}} Dictionary containing Cells X Channel matrices of data that are required to control (e.g. Raw matrix).\ngates::Dict{String,FlowCytometryGate} List of Gate and Gate set objects\nuns::Dict{String,Any} Dictionary contining all the metainformation of algorithms applied to the data.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Operations-with-structures","page":"API","title":"Operations with structures","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"removeCells\nremoveCells!\nremoveChannels\nremoveChannels!\nrenameControl!\ncheckControlNames","category":"page"},{"location":"API.html#FlowCytometry.removeCells","page":"API","title":"FlowCytometry.removeCells","text":"function removeCells(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove cells from the dataset and return a copy.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of cells to be removed.\n\nReturns FlowCytometryExperiment with the cells not prunned.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.removeCells!","page":"API","title":"FlowCytometry.removeCells!","text":"function removeCells!(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove cells from the dataset.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of cells to be removed.\n\nReturns Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.removeChannels","page":"API","title":"FlowCytometry.removeChannels","text":"function removeChannels(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove channels from the dataset and return a copy.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of channels to be removed.\n\nReturns FlowCytometryExperiment with the channels not removed.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.removeChannels!","page":"API","title":"FlowCytometry.removeChannels!","text":"function removeChannels!(fcs::FlowCytometryExperiment, s::Vector{Bool})\n\nRemove channels from the dataset.\n\nArguments:\n\nfcs::FlowCytometryExperiment Dataset to be pruned\ns::Vector{Bool} Array of channels to be removed.\n\nReturns FlowCytometryExperiment with the channels not removed.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.renameControl!","page":"API","title":"FlowCytometry.renameControl!","text":"function renameControl!(fcs::FlowCytometryControl,oldName::String,newName::AbstractString)\n\nChange the name of the a channel in the of a FlowCytometryControl object.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl where to change the name.\noldName::String Old name of the channel.\nnewName::AbstractString New name of the channel.\n\nReturns  Nothing\n\n\n\n\n\nfunction renameControl!(fcs::FlowCytometryControl,dic::Dict{<:AbstractString,<:AbstractString})\n\nChange the name of the channels in the of a FlowCytometryControl object.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl where to change the name.\ndic::Dict{<:AbstractString,<:AbstractString} Dictionary of old names as keys and new names as values.\n\nReturns  Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.checkControlNames","page":"API","title":"FlowCytometry.checkControlNames","text":"function checkControlNames(fcs::FlowCytometryControl)\n\nfunction that checks that the keys of the FlowCytometryControl object correspond to channels defined in .var.channels.\n\nArguemtns\n\nfcs::FlowCytometryControl FlowCytometryControl object where to check if consistent.\n\nReturns  Gives an error if there is any inconsistency.\n\n\n\n\n\n","category":"function"},{"location":"API.html#IO","page":"API","title":"IO","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"loadFCExperiment\nloadFCControls\nsaveH5fcs\nloadH5fcs","category":"page"},{"location":"API.html#FlowCytometry.loadFCExperiment","page":"API","title":"FlowCytometry.loadFCExperiment","text":"function loadFCExperiment(file::String)\n\nFunction that loads a ftc experiment into a FlowCytometryExperiment.\n\nArguments:\n\nfile::String: Path to .ftc file.\n\nReturns:  FlowCytometryExperiment with the data from the uploaded file.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.loadFCControls","page":"API","title":"FlowCytometry.loadFCControls","text":"function loadFCControls(dic::Dict{String,String})\n\nFunction to upload all the files as given by a dictionary of control files and the corresponding channels.\n\nArguments\n\ndic::Dict{String,String} Dictionary with name_of_file=>name_of_controlled_channel.\n\nReturns  FlowCytometryControl object with all the controls uploaded.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.saveH5fcs","page":"API","title":"FlowCytometry.saveH5fcs","text":"function saveH5fcs(fcs::FlowCytometryExperiment,file::String)\n\nFunction to save in .h5fcs a FlowCytometryExperiment.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment to save.\nfile::String File name where to store the data.\n\nReturns Nothing\n\n\n\n\n\nfunction saveH5fcs(fcs::FlowCytometryControl,file::String)\n\nFunction to save in .h5fcs a FlowCytometryControl.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl to save.\nfile::String File name where to store the data.\n\nReturns Nothing\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.loadH5fcs","page":"API","title":"FlowCytometry.loadH5fcs","text":"function loadH5fcs(file::String)\n\nFunction to load .h5fcs files into data.\n\nArguments\n\nfile::String File name of the datafile.\n\nReturns FlowCytometryControl or FlowCytometryExperiment loaded from file.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Gating","page":"API","title":"Gating","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Gating.isInsideGate\nGating.filterByGate!\nGating.manualGating!\nGating.automaticQC!","category":"page"},{"location":"API.html#FlowCytometry.isInsideGate","page":"API","title":"FlowCytometry.isInsideGate","text":"function isInsideGate(p::Tuple{<:Real,<:Real}, gate::FlowCytometryGate)\n\nFunction that given a point and a gate, checks which entries are inside the gate polygon.\n\nArguments:\n\np::Tuple{<:Real,<:Real} Point to check if inside polygon.\ngate::FlowCytometryGate Gate to check if the rows are inside the polygon of the gate.\n\nReturns:  Bool. True entries are the ones inside the gate polygon.\n\n\n\n\n\nfunction isInsideGate(x::Matrix{<:Real}, gate::FlowCytometryGate)\n\nFunction that given the entries of two channels and a gate checks which entries are inside the gate polygon.\n\nArguments:\n\nx::Matrix{<:Real} Matrix with N cells and 2 columns (channels).\ngate::FlowCytometryGate Gate to check if the rows are inside the polygon of the gate.\n\nReturns:  Vector{Bool} with N entries. True entries are the ones inside the gate polygon.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Gating.filterByGate!","page":"API","title":"FlowCytometry.Gating.filterByGate!","text":"function filterByGate!(fcs::FlowCytometryExperiment,gate::FlowCytometryGate,addKey::String)\n\nFunction that checks which cells are inside a gate.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment where to compute the gate\ngate::FlowCytometryGate Gate to filter the cells.\naddKey::String Kay to be added in .obs\n\nReturns Nothing. A columns with addKey is added to .obs.\n\n\n\n\n\nfunction filterByGate!(fcs::FlowCytometryExperiment,gates::Vector{FlowCytometryGate},addKey::String)\n\nFunction that checks which cells are inside a set of gates.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment where to compute the gate\ngates::Vector{FlowCytometryGate} Set of gates to filter the cells.\naddKey::String Kay to be added in .obs\n\nReturns Nothing. A columns with addKey is added to .obs.\n\n\n\n\n\nfunction filterByGate!(fcs::FlowCytometryExperiment,gateName::String,addKey=string(gateName,\"_gate\"))\n\nFunction that checks which cells are inside a gate.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment where to compute the gate\ngateName::String Name of gate inside FlowCytometryExperiment.\naddKey::String=string(gateName,\"_gate\") Key to be added in .obs\n\nReturns Nothing. A columns with addKey is added to .obs.\n\n\n\n\n\nfunction filterByGate!(fcs::FlowCytometryExperiment,gateNames::Vector{String},addKey)\n\nFunction that checks which cells are inside a set of gates.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment where to compute the gate\ngateNames::Vector{String} Name of gates inside FlowCytometryExperiment.\naddKey::String=string(gateName,\"_gate\") Key to be added in .obs\n\nReturns Nothing. A columns with addKey is added to .obs.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Gating.manualGating!","page":"API","title":"FlowCytometry.Gating.manualGating!","text":"function manualGating!(fcs::FlowCytometryExperiment;debug=false)\n\nLaunch an interactive page accessible at localhost to define gates manually.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment object where to define the gates.\n\nReturns  Nothing. Adds or removes the gates to the object in place.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Gating.automaticQC!","page":"API","title":"FlowCytometry.Gating.automaticQC!","text":"function automaticQC!(fcs::FlowCytometryExperiment;\n    channel1=\"FSC-A\",channel2=\"SSC-A\",\n    trim::Tuple{<:Real,<:Real}=(0.01,0.99),\n    maxtrim::Real=.05,\n    densityBandwidth::Tuple{<:Real,<:Real}=(.5,.3),\n    finalBandwidth=.1,\n    heightFromMax=.3,\n    subsample=2000,\n    keyAdded=\"automaticQC\",\n    seed = 0)\n\nFunction that automatically detects the main peak corresponding to viable cells in a FCS/SSC scatterplot and adds a gate to the object.  The method follows the heuristics of Roca et al with some small adaptations.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment where to compute the gate\n\nKeyword arguments\n\nchannel1=\"FSC-A\" Channel name in channels corrresponding to the forwad scatter\nchannel2=\"SSC-A\" Channel name in channels corrresponding to the forwad scatter\ntrim::Tuple{<:Real,<:Real}=(0.01,0.99) Percentile range in the channel ranges to use in the analysis before finding maximums.\nmaxtrim::Real=.05 Minimum in the range channels where to accept maximum points. This avoids the peak present in some datasets at lower expressions (debris).\ndensityBandwidth::Tuple{<:Real,<:Real}=(.5,.3) Relative bandwidth to smooth the density plots.\nfinalBandwidth=.1 Relative bandwidth to smooth the density plots in the final step.\nheightFromMax=.3 In the last step, heigh at global maximum where to draw the contour of the QC region. Points with more probability that that will be used to make the QC gate.\nsubsample=2000 Subsample of points used for density steps of the system. Set to 'nothing' for using all the points (this can be extremely slow), with relative low numbers of points the gate output are already very good.\nkeyAdded=\"automaticQC\" Key added to uns and gate name.\nseed = 0 Seed to make subsampling reproducible.\n\nReturns Nothing. A gate of automatic control is added to gates.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Compensation-(Spillover/Unmixing)","page":"API","title":"Compensation (Spillover/Unmixing)","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Compensation.computeCompensationMatrix!\nCompensation.compensate!","category":"page"},{"location":"API.html#FlowCytometry.Compensation.computeCompensationMatrix!","page":"API","title":"FlowCytometry.Compensation.computeCompensationMatrix!","text":"function computeCompensationMatrix!(fcs::FlowCytometryControl; error::AbstractFloat = 10E-5, nMaxiterations::Int=10)\n\nCompute the compensation matrix as proposed by Roca et al.\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl where to compute the spillover matrix.\n\nKeyword arguments\n\nerror::AbstractFloat = 10E-5 Maximum error to stop the refinement of the spillover matrix.\nnMaxIterations::Int=10 Maximum number of iterations of the refinement matrix. Set to 0 to compute the classical spillover matrix.\n\nResults  Nothing. Adds the compensation matrix to the FlowCytometryControl object.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.Compensation.compensate!","page":"API","title":"FlowCytometry.Compensation.compensate!","text":"function compensate!(fcs::FlowCytometryControl)\n\nCompensate all the control experiments with the compensationMatrix of the object\n\nArguments\n\nfcs::FlowCytometryControl FlowCytometryControl object where to compute the compensation.\n\nReturns Nothing\n\n\n\n\n\nfunction compensate!(fcs::FlowCytometryExperiment,compensation::CompensationMatrix)\n\nCompensate FlowCytometryExperiment experiment with the compensationMatrix from an FlowCytometryControl object.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment object where to compute the compensation.\ncompensation::CompensationMatrix CompensationMatrix object\n\nReturns Nothing, compensated the matrix X from fcs.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Dimensionaity-reduction","page":"API","title":"Dimensionaity reduction","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"DimensionalityReduction.pca!\nDimensionalityReduction.umap!","category":"page"},{"location":"API.html#FlowCytometry.DimensionalityReduction.pca!","page":"API","title":"FlowCytometry.DimensionalityReduction.pca!","text":"function pca!(fct::FlowCytometryExperiment;\n    maxoutdim::Int = 0,\n    method::Symbol = :auto,\n    variance_ratio::Float64 = 0.99,\n    mean = nothing,\n    key_added::String = \"pca\",\n    key_used_channels::Union{Nothing,String} = nothing\n    )\n\nPerform pca analysis over the channels.\n\nArguments:\n\nfct::FlowCytometryExperiment FlowCytometryExperiment to perform the pca.\n\nKeyword Arguments\n\nmaxoutdim = 0 Number of PCS to compute if 0, it will compute NChannels-1\nmethod = :auto Method to compute pca. Choose between :svd, :cov and :auto.\nvariance_ratio = 0.99 Variance ratio up to which compute pca.\nmean = nothing If to consider the normalization as performed. nothing will consider the mean not adjusted.\nkey_added::String = \"pca\" Key to be added to object.\nkeyusedchannels::Union{Nothing,String} = nothing Bool column from .var specifying which channels to use for clustering.\n\nReturns  Nothing. To the FlowCytometryExperiment object provided, PCs are added to the .obsm[keyadded] and information of the algorithm if included in .uns[keyadded].\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.DimensionalityReduction.umap!","page":"API","title":"FlowCytometry.DimensionalityReduction.umap!","text":"function umap!(fct::FlowCytometryExperiment;\n    n_dims::Int = 2,\n    key_added::String = \"umap\",\n    key_obsm::Union{Nothing,String} = nothing,\n    n_components::Union{Nothing,Int} = nothing,\n    key_used_channels::Union{Nothing,String} = nothing,\n    kwargs...\n    )\n\nFunction that computes the UMAP plot of the neighbors.\n\nArguments\n\nfct::FlowCytometryExperiment FlowCytometryExperiment to perform the UMAP.\n\nKeyword Arguments\n\nn_dims::Int = 2 Number of dimensions for the projection.\nkey_added::String = \"KMeans\" Key to be added to object.\nkey_obsm::Union{Nothing,String} = nothing Matrix in .obsm to use for the clustering. Only keyobsm or keyused_channels can be specified.\nn_components::Union{Nothing,Int} = nothing Number of components to use from the .obsm.\nkeyusedchannels::Union{Nothing,String} = nothing Bool column from .var specifying which channels to use for clustering.\nkwargs... Keyword argumetns for the UMAP_ function. Do ?FlowCytometry.UMAP_ for more details on the keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Clustering","page":"API","title":"Clustering","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"<!– Clustering.kmeansTuning Clustering.agglomerative! –>","category":"page"},{"location":"API.html","page":"API","title":"API","text":"Clustering.kmeans!\nClustering.gaussianMixture!","category":"page"},{"location":"API.html#FlowCytometry.Clustering.kmeans!","page":"API","title":"FlowCytometry.Clustering.kmeans!","text":"function kmeans!(fct::FlowCytometryExperiment;\n    k::Int = 2, \n    metric = Distances.SqEuclidean(0.0),\n    init::Symbol = :kmpp,\n    key_added::String = \"kmeans\",\n    key_obsm::Union{Nothing,String} = nothing,\n    n_components::Union{Nothing,Int} = nothing,\n    key_used_channels::Union{Nothing,String} = nothing)\n\nFunction that clusters the data using the KMeans algorithm. To help asses the number of clusters you can use KMeansTuning function.\n\nArguments\n\nfct::FlowCytometryExperiment FlowCytometryExperiment to cluster the data.\n\nKeyword Arguments\n\nk::Int Number of clusters to partition the data.\nmetric = Distances.SqEuclidean(0.0) Metric to compute distances. \ninit::Symbol = :kmpp Initialisation algorithm of the KMeans. Choose between :kmpp, :rand or :kmenc. ?Clustering.kmeans_ for more information.\nkey_added::String = \"KMeans\" Key to be added to object.\nkey_obsm::Union{Nothing,String} = nothing Matrix in .obsm to use for the clustering. Only keyobsm or keyused_channels can be specified.\nn_components::Union{Nothing,Int} = nothing Number of components to use from the .obsm.\nkey_used _channels::Union{Nothing,String} = nothing Bool column from .var specifying which channels to use for clustering.\n\nReturns  Nothing. To the FlowCytometryExperiment object provided, clusters identities are added to the .obs[keyadded] and information of the algorithm if included in .uns[keyadded].\n\n\n\n\n\n","category":"function"},{"location":"API.html#Ploting","page":"API","title":"Ploting","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"FCSPloting.plotQCSteps\nFCSPloting.plotControls\nFCSPloting.plotControlsCorrelations","category":"page"},{"location":"API.html#FlowCytometry.FCSPloting.plotQCSteps","page":"API","title":"FlowCytometry.FCSPloting.plotQCSteps","text":"function plotQCSteps(fcs::FlowCytometryExperiment,key::String=\"automaticQC\")\n\nFunction that returns the ploting steps from automaticQC.\n\nArguments\n\nfcs::FlowCytometryExperiment FlowCytometryExperiment object where to define the gates.\nkey::String=\"automaticQC\" Key used to save the results from the automatic control object.\n\nReturns  Figure with the steps ploted.\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.FCSPloting.plotControls","page":"API","title":"FlowCytometry.FCSPloting.plotControls","text":"function plotControls(fcsControl::FlowCytometryControl,channels::Vector{Tuple{String,String}})\n\nFunction that makes an scatterplot of the tuples of channels among controls and channels to see the spillover. If computeCompensationMatrix! has been computed, it also plots the correction after the control.\n\nArguments:\n\nfcsControl::FlowCytometryControl FlowCytometryControl object where to check the spillover.\nchannels::Vector{Tuple{String,String}} Vetor of Tuples of control sample and spilled channel that want to be seen.\n\nReturns List of figures with all the scatterplots between tuples. It can be ploted using plot(returned...,layout=(...))\n\n\n\n\n\n","category":"function"},{"location":"API.html#FlowCytometry.FCSPloting.plotControlsCorrelations","page":"API","title":"FlowCytometry.FCSPloting.plotControlsCorrelations","text":"function plotControlsCorrelations(fcsControl::FlowCytometryControl)\n\nFunction that displays a heatmap with the correlation between controls and channels. It can work as a summary of spillover between data.\n\nArguments:\n\nfcsControl::FlowCytometryControl FlowCytometryControl object to compute the correlations between channels.\n\nReturn  Heatmap figure with the control channels in rows and channels in columns.\n\n\n\n\n\n","category":"function"}]
}
